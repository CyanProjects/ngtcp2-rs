#![allow(non_camel_case_types)]
/* automatically generated by rust-bindgen 0.72.0 */

pub type __socklen_t = ::std::os::raw::c_uint;
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[doc = " @typedef\n\n :type:`ngtcp2_ssize` is signed counterpart of size_t."]
pub type ngtcp2_ssize = isize;
#[doc = " @functypedef\n\n :type:`ngtcp2_malloc` is a custom memory allocator to replace\n :manpage:`malloc(3)`.  The |user_data| is\n :member:`ngtcp2_mem.user_data`."]
pub type ngtcp2_malloc = ::std::option::Option<
    unsafe extern "C" fn(
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_free` is a custom memory allocator to replace\n :manpage:`free(3)`.  The |user_data| is\n :member:`ngtcp2_mem.user_data`."]
pub type ngtcp2_free = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_calloc` is a custom memory allocator to replace\n :manpage:`calloc(3)`.  The |user_data| is the\n :member:`ngtcp2_mem.user_data`."]
pub type ngtcp2_calloc = ::std::option::Option<
    unsafe extern "C" fn(
        nmemb: usize,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_realloc` is a custom memory allocator to replace\n :manpage:`realloc(3)`.  The |user_data| is the\n :member:`ngtcp2_mem.user_data`."]
pub type ngtcp2_realloc = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @struct\n\n :type:`ngtcp2_mem` is a custom memory allocator.  The\n :member:`user_data` field is passed to each allocator function.\n This can be used, for example, to achieve per-connection memory\n pool.\n\n In the following example code, ``my_malloc``, ``my_free``,\n ``my_calloc`` and ``my_realloc`` are the replacement of the\n standard allocators :manpage:`malloc(3)`, :manpage:`free(3)`,\n :manpage:`calloc(3)` and :manpage:`realloc(3)` respectively::\n\n     void *my_malloc_cb(size_t size, void *user_data) {\n       (void)user_data;\n       return my_malloc(size);\n     }\n\n     void my_free_cb(void *ptr, void *user_data) {\n       (void)user_data;\n       my_free(ptr);\n     }\n\n     void *my_calloc_cb(size_t nmemb, size_t size, void *user_data) {\n       (void)user_data;\n       return my_calloc(nmemb, size);\n     }\n\n     void *my_realloc_cb(void *ptr, size_t size, void *user_data) {\n       (void)user_data;\n       return my_realloc(ptr, size);\n     }\n\n     void conn_new() {\n       ngtcp2_mem mem = {\n         .malloc = my_malloc_cb,\n         .free = my_free_cb,\n         .calloc = my_calloc_cb,\n         .realloc = my_realloc_cb,\n       };\n\n       ...\n     }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_mem {
    #[doc = " :member:`user_data` is an arbitrary user supplied data.  This\n is passed to each allocator function."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " :member:`malloc` is a custom allocator function to replace\n :manpage:`malloc(3)`."]
    pub malloc: ngtcp2_malloc,
    #[doc = " :member:`free` is a custom allocator function to replace\n :manpage:`free(3)`."]
    pub free: ngtcp2_free,
    #[doc = " :member:`calloc` is a custom allocator function to replace\n :manpage:`calloc(3)`."]
    pub calloc: ngtcp2_calloc,
    #[doc = " :member:`realloc` is a custom allocator function to replace\n :manpage:`realloc(3)`."]
    pub realloc: ngtcp2_realloc,
}
#[doc = " @struct\n\n :type:`ngtcp2_pkt_info` is a packet metadata."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_pkt_info {
    #[doc = " :member:`ecn` is ECN marking, and when it is passed to\n `ngtcp2_conn_read_pkt()`, it should be either\n :macro:`NGTCP2_ECN_NOT_ECT`, :macro:`NGTCP2_ECN_ECT_1`,\n :macro:`NGTCP2_ECN_ECT_0`, or :macro:`NGTCP2_ECN_CE`."]
    pub ecn: u8,
}
#[doc = " :enum:`NGTCP2_PKT_VERSION_NEGOTIATION` is defined by libngtcp2\n for convenience."]
pub const NGTCP2_PKT_VERSION_NEGOTIATION: ngtcp2_pkt_type = 128;
#[doc = " :enum:`NGTCP2_PKT_STATELESS_RESET` is defined by libngtcp2 for\n convenience."]
pub const NGTCP2_PKT_STATELESS_RESET: ngtcp2_pkt_type = 129;
#[doc = " :enum:`NGTCP2_PKT_INITIAL` indicates Initial packet."]
pub const NGTCP2_PKT_INITIAL: ngtcp2_pkt_type = 16;
#[doc = " :enum:`NGTCP2_PKT_0RTT` indicates 0-RTT packet."]
pub const NGTCP2_PKT_0RTT: ngtcp2_pkt_type = 17;
#[doc = " :enum:`NGTCP2_PKT_HANDSHAKE` indicates Handshake packet."]
pub const NGTCP2_PKT_HANDSHAKE: ngtcp2_pkt_type = 18;
#[doc = " :enum:`NGTCP2_PKT_RETRY` indicates Retry packet."]
pub const NGTCP2_PKT_RETRY: ngtcp2_pkt_type = 19;
#[doc = " :enum:`NGTCP2_PKT_1RTT` is defined by libngtcp2 for convenience."]
pub const NGTCP2_PKT_1RTT: ngtcp2_pkt_type = 64;
#[doc = " @enum\n\n :type:`ngtcp2_pkt_type` defines QUIC version-independent QUIC\n packet types."]
pub type ngtcp2_pkt_type = ::std::os::raw::c_uint;
#[doc = " :enum:`NGTCP2_PATH_VALIDATION_RESULT_SUCCESS` indicates\n successful validation."]
pub const NGTCP2_PATH_VALIDATION_RESULT_SUCCESS: ngtcp2_path_validation_result = 0;
#[doc = " :enum:`NGTCP2_PATH_VALIDATION_RESULT_FAILURE` indicates\n validation failure."]
pub const NGTCP2_PATH_VALIDATION_RESULT_FAILURE: ngtcp2_path_validation_result = 1;
#[doc = " :enum:`NGTCP2_PATH_VALIDATION_RESULT_ABORTED` indicates that path\n validation was aborted."]
pub const NGTCP2_PATH_VALIDATION_RESULT_ABORTED: ngtcp2_path_validation_result = 2;
#[doc = " @enum\n\n :type:`ngtcp2_path_validation_result` defines path validation\n result code."]
pub type ngtcp2_path_validation_result = ::std::os::raw::c_uint;
#[doc = " @typedef\n\n :type:`ngtcp2_tstamp` is a timestamp with nanosecond resolution.\n ``UINT64_MAX`` is an invalid value, and it is often used to\n indicate that no value is set."]
pub type ngtcp2_tstamp = u64;
#[doc = " @typedef\n\n :type:`ngtcp2_duration` is a period of time in nanosecond\n resolution.  ``UINT64_MAX`` is an invalid value, and it is often\n used to indicate that no value is set."]
pub type ngtcp2_duration = u64;
#[doc = " @struct\n\n :type:`ngtcp2_cid` holds a Connection ID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_cid {
    #[doc = " :member:`datalen` is the length of Connection ID."]
    pub datalen: usize,
    #[doc = " :member:`data` is the buffer to store Connection ID."]
    pub data: [u8; 20usize],
}
#[doc = " @struct\n\n :type:`ngtcp2_vec` is struct iovec compatible structure to\n reference arbitrary array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_vec {
    #[doc = " :member:`base` points to the data."]
    pub base: *mut u8,
    #[doc = " :member:`len` is the number of bytes which the buffer pointed by\n base contains."]
    pub len: usize,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_cid_init` initializes Connection ID |cid| with the byte\n string pointed by |data| and its length is |datalen|.  |datalen|\n must be at most :macro:`NGTCP2_MAX_CIDLEN`."]
    pub fn ngtcp2_cid_init(cid: *mut ngtcp2_cid, data: *const u8, datalen: usize);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_cid_eq` returns nonzero if |a| and |b| share the same\n Connection ID."]
    pub fn ngtcp2_cid_eq(a: *const ngtcp2_cid, b: *const ngtcp2_cid) -> ::std::os::raw::c_int;
}
#[doc = " @struct\n\n :type:`ngtcp2_pkt_hd` represents QUIC packet header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_pkt_hd {
    #[doc = " :member:`dcid` is Destination Connection ID."]
    pub dcid: ngtcp2_cid,
    #[doc = " :member:`scid` is Source Connection ID."]
    pub scid: ngtcp2_cid,
    #[doc = " :member:`pkt_num` is a packet number."]
    pub pkt_num: i64,
    #[doc = " :member:`token` contains token.  Only Initial packet may contain\n token.  NULL if no token is present."]
    pub token: *const u8,
    #[doc = " :member:`tokenlen` is the length of :member:`token`.  0 if no\n token is present."]
    pub tokenlen: usize,
    #[doc = " :member:`pkt_numlen` is the number of bytes spent to encode\n :member:`pkt_num`."]
    pub pkt_numlen: usize,
    #[doc = " :member:`len` is the sum of :member:`pkt_numlen` and the length\n of QUIC packet payload."]
    pub len: usize,
    #[doc = " :member:`version` is QUIC version."]
    pub version: u32,
    #[doc = " :member:`type` is a type of QUIC packet.  This field does not\n have a QUIC packet type defined for a specific QUIC version.\n Instead, it contains version independent packet type defined by\n this library.  See :type:`ngtcp2_pkt_type`."]
    pub type_: u8,
    #[doc = " :member:`flags` is zero or more of :macro:`NGTCP2_PKT_FLAG_*\n <NGTCP2_PKT_FLAG_NONE>`."]
    pub flags: u8,
}
#[doc = " @struct\n\n :type:`ngtcp2_pkt_stateless_reset` represents Stateless Reset."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_pkt_stateless_reset {
    #[doc = " :member:`stateless_reset_token` contains stateless reset token."]
    pub stateless_reset_token: [u8; 16usize],
    #[doc = " :member:`rand` points a buffer which contains random bytes\n section."]
    pub rand: *const u8,
    #[doc = " :member:`randlen` is the number of random bytes."]
    pub randlen: usize,
}
#[doc = " @typedef\n\n :type:`ngtcp2_sockaddr` is typedefed to struct sockaddr.  If\n :macro:`NGTCP2_USE_GENERIC_SOCKADDR` is defined, it is typedefed to\n the generic struct sockaddr defined in ngtcp2.h."]
pub type ngtcp2_sockaddr = sockaddr;
#[doc = " @typedef\n\n :type:`ngtcp2_sockaddr_in` is typedefed to struct sockaddr_in.  If\n :macro:`NGTCP2_USE_GENERIC_SOCKADDR` is defined, it is typedefed to\n the generic struct sockaddr_in defined in ngtcp2.h."]
pub type ngtcp2_sockaddr_in = sockaddr_in;
#[doc = " @typedef\n\n :type:`ngtcp2_sockaddr_in6` is typedefed to struct sockaddr_in6.\n If :macro:`NGTCP2_USE_GENERIC_SOCKADDR` is defined, it is typedefed\n to the generic struct sockaddr_in6 defined in ngtcp2.h."]
pub type ngtcp2_sockaddr_in6 = sockaddr_in6;
#[doc = " @typedef\n\n :type:`ngtcp2_socklen` is typedefed to socklen_t.  If\n :macro:`NGTCP2_USE_GENERIC_SOCKADDR` is defined, it is typedefed to\n uint32_t."]
pub type ngtcp2_socklen = socklen_t;
#[doc = " @struct\n\n :type:`ngtcp2_sockaddr_union` conveniently includes all supported\n address types."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngtcp2_sockaddr_union {
    pub sa: ngtcp2_sockaddr,
    pub in_: ngtcp2_sockaddr_in,
    pub in6: ngtcp2_sockaddr_in6,
}
#[doc = " @struct\n\n :type:`ngtcp2_preferred_addr` represents preferred address\n structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngtcp2_preferred_addr {
    #[doc = " :member:`cid` is a Connection ID."]
    pub cid: ngtcp2_cid,
    #[doc = " :member:`ipv4` contains IPv4 address and port."]
    pub ipv4: ngtcp2_sockaddr_in,
    #[doc = " :member:`ipv6` contains IPv6 address and port."]
    pub ipv6: ngtcp2_sockaddr_in6,
    #[doc = " :member:`ipv4_present` indicates that :member:`ipv4` contains\n IPv4 address and port."]
    pub ipv4_present: u8,
    #[doc = " :member:`ipv6_present` indicates that :member:`ipv6` contains\n IPv6 address and port."]
    pub ipv6_present: u8,
    #[doc = " :member:`stateless_reset_token` contains stateless reset token."]
    pub stateless_reset_token: [u8; 16usize],
}
#[doc = " @struct\n\n :type:`ngtcp2_version_info` represents version_information\n structure.  See :rfc:`9368`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_version_info {
    #[doc = " :member:`chosen_version` is the version chosen by the sender."]
    pub chosen_version: u32,
    #[doc = " :member:`available_versions` points the wire image of\n available_versions field.  The each version is therefore in\n network byte order."]
    pub available_versions: *const u8,
    #[doc = " :member:`available_versionslen` is the number of bytes pointed by\n :member:`available_versions`, not the number of versions\n included."]
    pub available_versionslen: usize,
}
#[doc = " @struct\n\n :type:`ngtcp2_transport_params` represents QUIC transport\n parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngtcp2_transport_params {
    #[doc = " :member:`preferred_addr` contains preferred address if\n :member:`preferred_addr_present` is nonzero."]
    pub preferred_addr: ngtcp2_preferred_addr,
    #[doc = " :member:`original_dcid` is the Destination Connection ID field\n from the first Initial packet from client.  Server must specify\n this field and set :member:`original_dcid_present` to nonzero.\n It is expected that application knows the original Destination\n Connection ID even if it sends Retry packet, for example, by\n including it in retry token.  Otherwise, application should not\n specify this field."]
    pub original_dcid: ngtcp2_cid,
    #[doc = " :member:`initial_scid` is the Source Connection ID field from the\n first Initial packet the local endpoint sends.  Application\n should not specify this field.  If :member:`initial_scid_present`\n is set to nonzero, it indicates this field is set."]
    pub initial_scid: ngtcp2_cid,
    #[doc = " :member:`retry_scid` is the Source Connection ID field from Retry\n packet.  Only server uses this field.  If server application\n received Initial packet with retry token from client, and server\n successfully verified its token, server application must set\n Destination Connection ID field from the Initial packet to this\n field, and set :member:`retry_scid_present` to nonzero.  Server\n application must verify that the Destination Connection ID from\n Initial packet was sent in Retry packet by, for example,\n including the Connection ID in a token, or including it in AAD\n when encrypting a token."]
    pub retry_scid: ngtcp2_cid,
    #[doc = " :member:`initial_max_stream_data_bidi_local` is the size of flow\n control window of locally initiated stream.  This is the number\n of bytes that the remote endpoint can send, and the local\n endpoint must ensure that it has enough buffer to receive them."]
    pub initial_max_stream_data_bidi_local: u64,
    #[doc = " :member:`initial_max_stream_data_bidi_remote` is the size of flow\n control window of remotely initiated stream.  This is the number\n of bytes that the remote endpoint can send, and the local\n endpoint must ensure that it has enough buffer to receive them."]
    pub initial_max_stream_data_bidi_remote: u64,
    #[doc = " :member:`initial_max_stream_data_uni` is the size of flow control\n window of remotely initiated unidirectional stream.  This is the\n number of bytes that the remote endpoint can send, and the local\n endpoint must ensure that it has enough buffer to receive them."]
    pub initial_max_stream_data_uni: u64,
    #[doc = " :member:`initial_max_data` is the connection level flow control\n window."]
    pub initial_max_data: u64,
    #[doc = " :member:`initial_max_streams_bidi` is the number of concurrent\n streams that the remote endpoint can create."]
    pub initial_max_streams_bidi: u64,
    #[doc = " :member:`initial_max_streams_uni` is the number of concurrent\n unidirectional streams that the remote endpoint can create."]
    pub initial_max_streams_uni: u64,
    #[doc = " :member:`max_idle_timeout` is a duration during which sender\n allows quiescent.  0 means no idle timeout.  It must not be\n UINT64_MAX."]
    pub max_idle_timeout: ngtcp2_duration,
    #[doc = " :member:`max_udp_payload_size` is the maximum UDP payload size\n that the local endpoint can receive."]
    pub max_udp_payload_size: u64,
    #[doc = " :member:`active_connection_id_limit` is the maximum number of\n Connection ID that sender can store.  If specified, it must be in\n the range of [:macro:`NGTCP2_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT`,\n 8], inclusive."]
    pub active_connection_id_limit: u64,
    #[doc = " :member:`ack_delay_exponent` is the exponent used in ACK Delay\n field in ACK frame."]
    pub ack_delay_exponent: u64,
    #[doc = " :member:`max_ack_delay` is the maximum acknowledgement delay by\n which the local endpoint will delay sending acknowledgements.  It\n must be strictly less than (1 << 14) milliseconds.\n Sub-millisecond part is dropped when sending it in a QUIC\n transport parameter."]
    pub max_ack_delay: ngtcp2_duration,
    #[doc = " :member:`max_datagram_frame_size` is the maximum size of DATAGRAM\n frame that the local endpoint willingly receives.  Specifying 0\n disables DATAGRAM support.  See :rfc:`9221`."]
    pub max_datagram_frame_size: u64,
    #[doc = " :member:`stateless_reset_token_present` is nonzero if\n :member:`stateless_reset_token` field is set."]
    pub stateless_reset_token_present: u8,
    #[doc = " :member:`disable_active_migration` is nonzero if the local\n endpoint does not support active connection migration."]
    pub disable_active_migration: u8,
    #[doc = " :member:`original_dcid_present` is nonzero if\n :member:`original_dcid` field is set."]
    pub original_dcid_present: u8,
    #[doc = " :member:`initial_scid_present` is nonzero if\n :member:`initial_scid` field is set."]
    pub initial_scid_present: u8,
    #[doc = " :member:`retry_scid_present` is nonzero if :member:`retry_scid`\n field is set."]
    pub retry_scid_present: u8,
    #[doc = " :member:`preferred_addr_present` is nonzero if\n :member:`preferred_address` is set."]
    pub preferred_addr_present: u8,
    #[doc = " :member:`stateless_reset_token` contains stateless reset token."]
    pub stateless_reset_token: [u8; 16usize],
    #[doc = " :member:`grease_quic_bit` is nonzero if sender supports \"Greasing\n the QUIC Bit\" extension.  See :rfc:`9287`."]
    pub grease_quic_bit: u8,
    #[doc = " :member:`version_info` contains version_information field if\n :member:`version_info_present` is nonzero.  Application should\n not specify this field."]
    pub version_info: ngtcp2_version_info,
    #[doc = " :member:`version_info_present` is nonzero if\n :member:`version_info` is set.  Application should not specify\n this field."]
    pub version_info_present: u8,
}
#[doc = " @struct\n\n :type:`ngtcp2_conn_info` holds various connection statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_conn_info {
    #[doc = " :member:`latest_rtt` is the latest RTT sample which is not\n adjusted by acknowledgement delay."]
    pub latest_rtt: ngtcp2_duration,
    #[doc = " :member:`min_rtt` is the minimum RTT seen so far.  It is not\n adjusted by acknowledgement delay."]
    pub min_rtt: ngtcp2_duration,
    #[doc = " :member:`smoothed_rtt` is the smoothed RTT."]
    pub smoothed_rtt: ngtcp2_duration,
    #[doc = " :member:`rttvar` is a mean deviation of observed RTT."]
    pub rttvar: ngtcp2_duration,
    #[doc = " :member:`cwnd` is the size of congestion window."]
    pub cwnd: u64,
    #[doc = " :member:`ssthresh` is slow start threshold."]
    pub ssthresh: u64,
    #[doc = " :member:`bytes_in_flight` is the number in bytes of all sent\n packets which have not been acknowledged."]
    pub bytes_in_flight: u64,
}
#[doc = " :enum:`NGTCP2_CC_ALGO_RENO` represents Reno."]
pub const NGTCP2_CC_ALGO_RENO: ngtcp2_cc_algo = 0;
#[doc = " :enum:`NGTCP2_CC_ALGO_CUBIC` represents Cubic."]
pub const NGTCP2_CC_ALGO_CUBIC: ngtcp2_cc_algo = 1;
#[doc = " :enum:`NGTCP2_CC_ALGO_BBR` represents BBR v2."]
pub const NGTCP2_CC_ALGO_BBR: ngtcp2_cc_algo = 2;
#[doc = " @enum\n\n :type:`ngtcp2_cc_algo` defines congestion control algorithms."]
pub type ngtcp2_cc_algo = ::std::os::raw::c_uint;
#[doc = " @functypedef\n\n :type:`ngtcp2_printf` is a callback function for logging.\n |user_data| is the same object passed to `ngtcp2_conn_client_new`\n or `ngtcp2_conn_server_new`."]
pub type ngtcp2_printf = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[doc = " @struct\n\n :type:`ngtcp2_rand_ctx` is a wrapper around native random number\n generator.  It is opaque to the ngtcp2 library.  This might be\n useful if application needs to specify random number generator per\n thread or per connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_rand_ctx {
    #[doc = " :member:`native_handle` is a pointer to an underlying random\n number generator."]
    pub native_handle: *mut ::std::os::raw::c_void,
}
#[doc = " @functypedef\n\n :type:`ngtcp2_qlog_write` is a callback function which is called to\n write qlog |data| of length |datalen| bytes.  |flags| is bitwise OR\n of zero or more of :macro:`NGTCP2_QLOG_WRITE_FLAG_*\n <NGTCP2_QLOG_WRITE_FLAG_NONE>`.  If\n :macro:`NGTCP2_QLOG_WRITE_FLAG_FIN` is set, |datalen| may be 0."]
pub type ngtcp2_qlog_write = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        flags: u32,
        data: *const ::std::os::raw::c_void,
        datalen: usize,
    ),
>;
#[doc = " :enum:`NGTCP2_TOKEN_TYPE_UNKNOWN` indicates that the type of\n token is unknown."]
pub const NGTCP2_TOKEN_TYPE_UNKNOWN: ngtcp2_token_type = 0;
#[doc = " :enum:`NGTCP2_TOKEN_TYPE_RETRY` indicates that a token comes from\n Retry packet."]
pub const NGTCP2_TOKEN_TYPE_RETRY: ngtcp2_token_type = 1;
#[doc = " :enum:`NGTCP2_TOKEN_TYPE_NEW_TOKEN` indicates that a token comes\n from NEW_TOKEN frame."]
pub const NGTCP2_TOKEN_TYPE_NEW_TOKEN: ngtcp2_token_type = 2;
#[doc = " @enum\n\n :type:`ngtcp2_token_type` defines the type of token."]
pub type ngtcp2_token_type = ::std::os::raw::c_uint;
#[doc = " @struct\n\n :type:`ngtcp2_settings` defines QUIC connection settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_settings {
    #[doc = " :member:`qlog_write` is a callback function to write qlog.\n Setting ``NULL`` disables qlog."]
    pub qlog_write: ngtcp2_qlog_write,
    #[doc = " :member:`cc_algo` specifies congestion control algorithm."]
    pub cc_algo: ngtcp2_cc_algo,
    #[doc = " :member:`initial_ts` is an initial timestamp given to the\n library."]
    pub initial_ts: ngtcp2_tstamp,
    #[doc = " :member:`initial_rtt` is an initial RTT."]
    pub initial_rtt: ngtcp2_duration,
    #[doc = " :member:`log_printf` is a function that the library uses to write\n logs.  ``NULL`` means no logging output.  It is nothing to do\n with qlog."]
    pub log_printf: ngtcp2_printf,
    #[doc = " :member:`max_tx_udp_payload_size` is the maximum size of UDP\n datagram payload that the local endpoint transmits."]
    pub max_tx_udp_payload_size: usize,
    #[doc = " :member:`token` is a token from Retry packet or NEW_TOKEN frame.\n\n Server sets this field if it received the token in Client Initial\n packet and successfully validated.  It should also set\n :member:`token_type` field.\n\n Client sets this field if it intends to send token in its Initial\n packet.\n\n `ngtcp2_conn_server_new` and `ngtcp2_conn_client_new` make a copy\n of token.\n\n Set NULL if there is no token."]
    pub token: *const u8,
    #[doc = " :member:`tokenlen` is the length of :member:`token`.  Set 0 if\n there is no token."]
    pub tokenlen: usize,
    #[doc = " :member:`token_type` is the type of token.  Server application\n should set this field."]
    pub token_type: ngtcp2_token_type,
    #[doc = " :member:`rand_ctx` is an optional random number generator to be\n passed to :type:`ngtcp2_rand` callback."]
    pub rand_ctx: ngtcp2_rand_ctx,
    #[doc = " :member:`max_window` is the maximum connection-level flow control\n window if connection-level window auto-tuning is enabled.  The\n connection-level window auto tuning is enabled if nonzero value\n is specified in this field.  The initial value of window size is\n :member:`ngtcp2_transport_params.initial_max_data`.  The window\n size is scaled up to the value specified in this field."]
    pub max_window: u64,
    #[doc = " :member:`max_stream_window` is the maximum stream-level flow\n control window if stream-level window auto-tuning is enabled.\n The stream-level window auto-tuning is enabled if nonzero value\n is specified in this field.  The initial value of window size is\n :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_remote`,\n :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_local`,\n or :member:`ngtcp2_transport_params.initial_max_stream_data_uni`,\n depending on the type of stream.  The window size is scaled up to\n the value specified in this field.\n\n Please note that the auto-tuning is done per stream.  Even if the\n previous stream gets larger window as a result of auto-tuning,\n the new stream still starts with the initial value set in\n transport parameters.  This might become a bottleneck if\n congestion window of a remote server is wide open.  If this\n causes an issue, do not enable auto-tuning."]
    pub max_stream_window: u64,
    #[doc = " :member:`ack_thresh` is the minimum number of the received ACK\n eliciting packets that trigger the immediate acknowledgement from\n the local endpoint."]
    pub ack_thresh: usize,
    #[doc = " :member:`no_tx_udp_payload_size_shaping`, if set to nonzero,\n instructs the library not to limit the UDP payload size to\n :macro:`NGTCP2_MAX_UDP_PAYLOAD_SIZE` (which can be extended by\n Path MTU Discovery), and instead use the minimum size among the\n given buffer size, :member:`max_tx_udp_payload_size`, and the\n received max_udp_payload_size QUIC transport parameter."]
    pub no_tx_udp_payload_size_shaping: u8,
    #[doc = " :member:`handshake_timeout` is the period of time before giving\n up QUIC connection establishment.  If QUIC handshake is not\n complete within this period, `ngtcp2_conn_handle_expiry` returns\n :macro:`NGTCP2_ERR_HANDSHAKE_TIMEOUT` error.  The deadline is\n :member:`initial_ts` + :member:`handshake_timeout`.  If this\n field is set to ``UINT64_MAX``, no handshake timeout is set."]
    pub handshake_timeout: ngtcp2_duration,
    #[doc = " :member:`preferred_versions` is the array of versions that are\n preferred by the local endpoint.  All versions set in this array\n must be supported by the library, and compatible to QUIC v1.  The\n reserved versions are not allowed.  They are sorted in the order\n of preference.\n\n On compatible version negotiation, server will negotiate one of\n those versions contained in this array if there is some overlap\n between these versions and the versions offered by the client.\n If there is no overlap, but the client chosen version is\n supported by the library, the server chooses the client chosen\n version as the negotiated version.  This version set corresponds\n to Offered Versions described in :rfc:`9368`, and it should be\n included in Version Negotiation packet.\n\n Client uses this field and :member:`original_version` to prevent\n version downgrade attack if it reacted upon Version Negotiation\n packet.  If this field is specified, client must include\n |client_chosen_version| passed to `ngtcp2_conn_client_new` unless\n |client_chosen_version| is a reserved version."]
    pub preferred_versions: *const u32,
    #[doc = " :member:`preferred_versionslen` is the number of versions that\n are contained in the array pointed by\n :member:`preferred_versions`."]
    pub preferred_versionslen: usize,
    #[doc = " :member:`available_versions` is the array of versions that are\n going to be set in :member:`available_versions\n <ngtcp2_version_info.available_versions>` field of outgoing\n version_information QUIC transport parameter.\n\n For server, this corresponds to Fully-Deployed Versions described\n in :rfc:`9368`.  If this field is not set, it is set to\n :member:`preferred_versions` internally if\n :member:`preferred_versionslen` is not zero.  If this field is\n not set, and :member:`preferred_versionslen` is zero, this field\n is set to :macro:`NGTCP2_PROTO_VER_V1` internally.\n\n Client must include |client_chosen_version| passed to\n `ngtcp2_conn_client_new` in this array if this field is set and\n |client_chosen_version| is not a reserved version.  If this field\n is not set, |client_chosen_version| passed to\n `ngtcp2_conn_client_new` will be set in this field internally\n unless |client_chosen_version| is a reserved version."]
    pub available_versions: *const u32,
    #[doc = " :member:`available_versionslen` is the number of versions that\n are contained in the array pointed by\n :member:`available_versions`."]
    pub available_versionslen: usize,
    #[doc = " :member:`original_version` is the original version that client\n initially used to make a connection attempt.  If it is set, and\n it differs from |client_chosen_version| passed to\n `ngtcp2_conn_client_new`, the library assumes that client reacted\n upon Version Negotiation packet.  Server does not use this field."]
    pub original_version: u32,
    #[doc = " :member:`no_pmtud`, if set to nonzero, disables Path MTU\n Discovery."]
    pub no_pmtud: u8,
    #[doc = " :member:`initial_pkt_num` is the initial packet number for each\n packet number space.  It must be in range [0, INT32_MAX],\n inclusive."]
    pub initial_pkt_num: u32,
    #[doc = " :member:`pmtud_probes` is the array of UDP datagram payload size\n to probe during Path MTU Discovery.  The discovery is done in the\n order appeared in this array.  The size must be strictly larger\n than 1200, otherwise the behavior is undefined.  The maximum\n value in this array should be set to\n :member:`max_tx_udp_payload_size`.  If this field is not set, the\n predefined PMTUD probes are made.  This field has been available\n since v1.4.0."]
    pub pmtud_probes: *const u16,
    #[doc = " :member:`pmtud_probeslen` is the number of elements that are\n contained in the array pointed by :member:`pmtud_probes`.  This\n field has been available since v1.4.0."]
    pub pmtud_probeslen: usize,
}
#[doc = " @struct\n\n :type:`ngtcp2_addr` is the endpoint address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_addr {
    #[doc = " :member:`addr` points to the buffer which contains endpoint\n address.  It must not be ``NULL``."]
    pub addr: *mut ngtcp2_sockaddr,
    #[doc = " :member:`addrlen` is the length of :member:`addr`.  It must not\n be longer than sizeof(:type:`ngtcp2_sockaddr_union`)."]
    pub addrlen: ngtcp2_socklen,
}
#[doc = " @struct\n\n :type:`ngtcp2_path` is the network endpoints where a packet is sent\n and received."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_path {
    #[doc = " :member:`local` is the address of local endpoint."]
    pub local: ngtcp2_addr,
    #[doc = " :member:`remote` is the address of remote endpoint."]
    pub remote: ngtcp2_addr,
    #[doc = " :member:`user_data` is an arbitrary data and opaque to the\n library.\n\n Note that :type:`ngtcp2_path` is generally passed to\n :type:`ngtcp2_conn` by an application, and :type:`ngtcp2_conn`\n stores their copies.  Unfortunately, there is no way for the\n application to know when :type:`ngtcp2_conn` finished using a\n specific :type:`ngtcp2_path` object in mid connection, which\n means that the application cannot free the data pointed by this\n field.  Therefore, it is advised to use this field only when the\n data pointed by this field persists in an entire lifetime of the\n connection."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[doc = " @struct\n\n :type:`ngtcp2_path_storage` is a convenient struct to have buffers\n to store the longest addresses."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngtcp2_path_storage {
    #[doc = " :member:`path` stores network path."]
    pub path: ngtcp2_path,
    #[doc = " :member:`local_addrbuf` is a buffer to store local address."]
    pub local_addrbuf: ngtcp2_sockaddr_union,
    #[doc = " :member:`remote_addrbuf` is a buffer to store remote address."]
    pub remote_addrbuf: ngtcp2_sockaddr_union,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_md` is a wrapper around native message digest\n object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_md {
    #[doc = " :member:`native_handle` is a pointer to an underlying message\n digest object."]
    pub native_handle: *mut ::std::os::raw::c_void,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_aead` is a wrapper around native AEAD object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_aead {
    #[doc = " :member:`native_handle` is a pointer to an underlying AEAD\n object."]
    pub native_handle: *mut ::std::os::raw::c_void,
    #[doc = " :member:`max_overhead` is the number of additional bytes which\n AEAD encryption needs on encryption."]
    pub max_overhead: usize,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_cipher` is a wrapper around native cipher\n object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_cipher {
    #[doc = " :member:`native_handle` is a pointer to an underlying cipher\n object."]
    pub native_handle: *mut ::std::os::raw::c_void,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_aead_ctx` is a wrapper around native AEAD\n cipher context object.  It should be initialized with a specific\n key.  ngtcp2 library reuses this context object to encrypt or\n decrypt multiple packets."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_aead_ctx {
    #[doc = " :member:`native_handle` is a pointer to an underlying AEAD\n context object."]
    pub native_handle: *mut ::std::os::raw::c_void,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_cipher_ctx` is a wrapper around native cipher\n context object.  It should be initialized with a specific key.\n ngtcp2 library reuses this context object to encrypt or decrypt\n multiple packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_cipher_ctx {
    #[doc = " :member:`native_handle` is a pointer to an underlying cipher\n context object."]
    pub native_handle: *mut ::std::os::raw::c_void,
}
#[doc = " @struct\n\n :type:`ngtcp2_crypto_ctx` is a convenient structure to bind all\n crypto related objects in one place.  Use\n `ngtcp2_crypto_ctx_initial` to initialize this struct for Initial\n packet encryption.  For Handshake and 1-RTT packets, use\n `ngtcp2_crypto_ctx_tls`.  For 0-RTT packets, use\n `ngtcp2_crypto_ctx_tls_early`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_crypto_ctx {
    #[doc = " :member:`aead` is AEAD object."]
    pub aead: ngtcp2_crypto_aead,
    #[doc = " :member:`md` is message digest object."]
    pub md: ngtcp2_crypto_md,
    #[doc = " :member:`hp` is header protection cipher."]
    pub hp: ngtcp2_crypto_cipher,
    #[doc = " :member:`max_encryption` is the number of encryption which this\n key can be used with."]
    pub max_encryption: u64,
    #[doc = " :member:`max_decryption_failure` is the number of decryption\n failure with this key."]
    pub max_decryption_failure: u64,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_transport_params_encode` encodes |params| in |dest| of\n length |destlen|.\n\n If |dest| is NULL, and |destlen| is zero, this function just\n returns the number of bytes required to store the encoded transport\n parameters.\n\n This function returns the number of bytes written, or one of the\n following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small."]
    pub fn ngtcp2_transport_params_encode_versioned(
        dest: *mut u8,
        destlen: usize,
        transport_params_version: ::std::os::raw::c_int,
        params: *const ngtcp2_transport_params,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_transport_params_decode` decodes transport parameters in\n |data| of length |datalen|, and stores the result in the object\n pointed by |params|.\n\n If an optional parameter is missing, the default value is assigned.\n\n The following fields may point to somewhere inside the buffer\n pointed by |data| of length |datalen|:\n\n - :member:`ngtcp2_transport_params.version_info.available_versions\n   <ngtcp2_version_info.available_versions>`\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`\n     The input is malformed."]
    pub fn ngtcp2_transport_params_decode_versioned(
        transport_params_version: ::std::os::raw::c_int,
        params: *mut ngtcp2_transport_params,
        data: *const u8,
        datalen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_transport_params_decode_new` decodes transport parameters\n in |data| of length |datalen|, and stores the result in the object\n allocated dynamically.  The pointer to the allocated object is\n assigned to |*pparams|.  Unlike `ngtcp2_transport_params_decode`,\n all direct and indirect fields are also allocated dynamically if\n needed.\n\n |mem| is a memory allocator to allocate memory.  If |mem| is\n ``NULL``, the memory allocator returned by `ngtcp2_mem_default()`\n is used.\n\n If the optional parameters are missing, the default value is\n assigned.\n\n `ngtcp2_transport_params_del` frees the memory allocated by this\n function.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`\n     The input is malformed.\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_transport_params_decode_new(
        pparams: *mut *mut ngtcp2_transport_params,
        data: *const u8,
        datalen: usize,
        mem: *const ngtcp2_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_transport_params_del` frees the |params| which must be\n dynamically allocated by `ngtcp2_transport_params_decode_new`.\n\n |mem| is a memory allocator that allocated |params|.  If |mem| is\n ``NULL``, the memory allocator returned by `ngtcp2_mem_default()`\n is used.\n\n If |params| is ``NULL``, this function does nothing."]
    pub fn ngtcp2_transport_params_del(
        params: *mut ngtcp2_transport_params,
        mem: *const ngtcp2_mem,
    );
}
#[doc = " @struct\n\n :type:`ngtcp2_version_cid` is a convenient struct to store the\n result of `ngtcp2_pkt_decode_version_cid`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_version_cid {
    #[doc = " :member:`version` stores QUIC version."]
    pub version: u32,
    #[doc = " :member:`dcid` points to the Destination Connection ID."]
    pub dcid: *const u8,
    #[doc = " :member:`dcidlen` is the length of the Destination Connection ID\n pointed by :member:`dcid`."]
    pub dcidlen: usize,
    #[doc = " :member:`scid` points to the Source Connection ID."]
    pub scid: *const u8,
    #[doc = " :member:`scidlen` is the length of the Source Connection ID\n pointed by :member:`scid`."]
    pub scidlen: usize,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_decode_version_cid` extracts QUIC version, Destination\n Connection ID and Source Connection ID from the packet pointed by\n |data| of length |datalen|.  This function can handle Connection ID\n up to 255 bytes unlike `ngtcp2_pkt_decode_hd_long` or\n `ngtcp2_pkt_decode_hd_short` which are only capable of handling\n Connection ID less than or equal to :macro:`NGTCP2_MAX_CIDLEN`.\n Longer Connection ID is only valid if the version is unsupported\n QUIC version.\n\n If the given packet is Long header packet, this function extracts\n the version from the packet, and assigns it to\n :member:`dest->version <ngtcp2_version_cid.version>`.  It also\n extracts the pointer to the Destination Connection ID and its\n length, and assigns them to :member:`dest->dcid\n <ngtcp2_version_cid.dcid>` and :member:`dest->dcidlen\n <ngtcp2_version_cid.dcidlen>` respectively.  Similarly, it extracts\n the pointer to the Source Connection ID and its length, and assigns\n them to :member:`dest->scid <ngtcp2_version_cid.scid>` and\n :member:`dest->scidlen <ngtcp2_version_cid.scidlen>` respectively.\n |short_dcidlen| is ignored.\n\n If the given packet is Short header packet, :member:`dest->version\n <ngtcp2_version_cid.version>` will be 0, :member:`dest->scid\n <ngtcp2_version_cid.scid>` will be ``NULL``, and\n :member:`dest->scidlen <ngtcp2_version_cid.scidlen>` will be 0.\n Because the Short header packet does not have the length of\n Destination Connection ID, the caller has to pass the length in\n |short_dcidlen|.  This function extracts the pointer to the\n Destination Connection ID, and assigns it to :member:`dest->dcid\n <ngtcp2_version_cid.dcid>`.  |short_dcidlen| is assigned to\n :member:`dest->dcidlen <ngtcp2_version_cid.dcidlen>`.\n\n If Version Negotiation is required, this function returns\n :macro:`NGTCP2_ERR_VERSION_NEGOTIATION`.  Unlike the other error\n cases, all fields of |dest| are assigned as described above.\n\n This function returns 0 if it succeeds.  Otherwise, one of the\n following negative error code:\n\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     The function could not decode the packet header.\n :macro:`NGTCP2_ERR_VERSION_NEGOTIATION`\n     Version Negotiation packet should be sent."]
    pub fn ngtcp2_pkt_decode_version_cid(
        dest: *mut ngtcp2_version_cid,
        data: *const u8,
        datalen: usize,
        short_dcidlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_decode_hd_long` decodes QUIC long packet header in\n |pkt| of length |pktlen|.  This function only parses the input just\n before packet number field.\n\n This function does not verify that length field is correct.  In\n other words, this function succeeds even if length > |pktlen|.\n\n This function can handle Connection ID up to\n :macro:`NGTCP2_MAX_CIDLEN`.  Consider to use\n `ngtcp2_pkt_decode_version_cid` to get longer Connection ID.\n\n This function handles Version Negotiation specially.  If version\n field is 0, |pkt| must contain Version Negotiation packet.  Version\n Negotiation packet has random type in wire format.  For\n convenience, this function sets\n :enum:`ngtcp2_pkt_type.NGTCP2_PKT_VERSION_NEGOTIATION` to\n :member:`dest->type <ngtcp2_pkt_hd.type>`, clears\n :macro:`NGTCP2_PKT_FLAG_LONG_FORM` flag from :member:`dest->flags\n <ngtcp2_pkt_hd.flags>`, and sets 0 to :member:`dest->len\n <ngtcp2_pkt_hd.len>`.  Version Negotiation packet occupies a single\n packet.\n\n It stores the result in the object pointed by |dest|, and returns\n the number of bytes decoded to read the packet header if it\n succeeds, or one of the following error codes:\n\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     Packet is too short; or it is not a long header"]
    pub fn ngtcp2_pkt_decode_hd_long(
        dest: *mut ngtcp2_pkt_hd,
        pkt: *const u8,
        pktlen: usize,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_decode_hd_short` decodes QUIC short header in |pkt| of\n length |pktlen|.  Short header packet does not encode the length of\n Connection ID, thus we need the input from the outside.  |dcidlen|\n is the length of Destination Connection ID in packet header.  This\n function only parses the input just before packet number field.\n This function can handle Connection ID up to\n :macro:`NGTCP2_MAX_CIDLEN`.  Consider to use\n `ngtcp2_pkt_decode_version_cid` to get longer Connection ID.  It\n stores the result in the object pointed by |dest|, and returns the\n number of bytes decoded to read the packet header if it succeeds,\n or one of the following error codes:\n\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     Packet is too short; or it is not a short header"]
    pub fn ngtcp2_pkt_decode_hd_short(
        dest: *mut ngtcp2_pkt_hd,
        pkt: *const u8,
        pktlen: usize,
        dcidlen: usize,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_write_stateless_reset` writes Stateless Reset packet in\n the buffer pointed by |dest| whose length is |destlen|.\n |stateless_reset_token| is a pointer to the Stateless Reset Token,\n and its length must be :macro:`NGTCP2_STATELESS_RESET_TOKENLEN`\n bytes long.  |rand| specifies the random octets preceding Stateless\n Reset Token.  The length of |rand| is specified by |randlen| which\n must be at least :macro:`NGTCP2_MIN_STATELESS_RESET_RANDLEN` bytes\n long.\n\n If |randlen| is too long to write them all in the buffer, |rand| is\n written to the buffer as much as possible, and is truncated.\n\n This function returns the number of bytes written to the buffer, or\n one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     |randlen| is strictly less than\n     :macro:`NGTCP2_MIN_STATELESS_RESET_RANDLEN`."]
    pub fn ngtcp2_pkt_write_stateless_reset(
        dest: *mut u8,
        destlen: usize,
        stateless_reset_token: *const u8,
        rand: *const u8,
        randlen: usize,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_write_version_negotiation` writes Version Negotiation\n packet in the buffer pointed by |dest| whose length is |destlen|.\n |unused_random| should be generated randomly.  |dcid| is a\n Connection ID which appeared in a packet as a Source Connection ID\n sent by client which caused version negotiation.  Similarly, |scid|\n is a Connection ID which appeared in a packet as a Destination\n Connection ID sent by client.  |sv| is a list of supported\n versions, and |nsv| specifies the number of supported versions\n included in |sv|.\n\n This function returns the number of bytes written to the buffer, or\n one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small."]
    pub fn ngtcp2_pkt_write_version_negotiation(
        dest: *mut u8,
        destlen: usize,
        unused_random: u8,
        dcid: *const u8,
        dcidlen: usize,
        scid: *const u8,
        scidlen: usize,
        sv: *const u32,
        nsv: usize,
    ) -> ngtcp2_ssize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_conn {
    _unused: [u8; 0],
}
#[doc = " @functypedef\n\n :type:`ngtcp2_client_initial` is invoked when client application\n asks TLS stack to produce first TLS cryptographic handshake data.\n\n This implementation of this callback must get the first handshake\n data from TLS stack, and pass it to ngtcp2 library using\n `ngtcp2_conn_submit_crypto_data` function.  Make sure that before\n calling `ngtcp2_conn_submit_crypto_data` function, client\n application must create initial packet protection keys and IVs, and\n provide them to ngtcp2 library using\n `ngtcp2_conn_install_initial_key`.\n\n This callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library call\n return immediately."]
pub type ngtcp2_client_initial = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_client_initial` is invoked when server receives\n Initial packet from client.  An server application must implement\n this callback, and generate initial keys and IVs for both\n transmission and reception.  Install them using\n `ngtcp2_conn_install_initial_key`.  |dcid| is the Destination\n Connection ID in Initial packet received from client.  It is used\n to derive initial packet protection keys.\n\n The callback function must return 0 if it succeeds.  If an error\n occurs, return :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the\n library call return immediately."]
pub type ngtcp2_recv_client_initial = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        dcid: *const ngtcp2_cid,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " :enum:`NGTCP2_ENCRYPTION_LEVEL_INITIAL` is Initial encryption\n level."]
pub const NGTCP2_ENCRYPTION_LEVEL_INITIAL: ngtcp2_encryption_level = 0;
#[doc = " :enum:`NGTCP2_ENCRYPTION_LEVEL_HANDSHAKE` is Handshake encryption\n level."]
pub const NGTCP2_ENCRYPTION_LEVEL_HANDSHAKE: ngtcp2_encryption_level = 1;
#[doc = " :enum:`NGTCP2_ENCRYPTION_LEVEL_1RTT` is 1-RTT encryption level."]
pub const NGTCP2_ENCRYPTION_LEVEL_1RTT: ngtcp2_encryption_level = 2;
#[doc = " :enum:`NGTCP2_ENCRYPTION_LEVEL_0RTT` is 0-RTT encryption level."]
pub const NGTCP2_ENCRYPTION_LEVEL_0RTT: ngtcp2_encryption_level = 3;
#[doc = " @enum\n\n :type:`ngtcp2_encryption_level` is QUIC encryption level."]
pub type ngtcp2_encryption_level = ::std::os::raw::c_uint;
#[doc = " @functypedef\n\n :type`ngtcp2_recv_crypto_data` is invoked when crypto data is\n received.  The received data is pointed by |data|, and its length\n is |datalen|.  The |offset| specifies the offset where |data| is\n positioned.  |user_data| is the arbitrary pointer passed to\n `ngtcp2_conn_client_new` or `ngtcp2_conn_server_new`.  The ngtcp2\n library ensures that the crypto data is passed to the application\n in the increasing order of |offset|.  |datalen| is always strictly\n greater than 0.  |encryption_level| indicates the encryption level\n where this data is received.  Crypto data can never be received in\n :enum:`ngtcp2_encryption_level.NGTCP2_ENCRYPTION_LEVEL_0RTT`.\n\n The application should provide the given data to TLS stack.\n\n The callback function must return 0 if it succeeds, or one of the\n following negative error codes:\n\n - :macro:`NGTCP2_ERR_CRYPTO`\n - :macro:`NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM`\n - :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`\n - :macro:`NGTCP2_ERR_TRANSPORT_PARAM`\n - :macro:`NGTCP2_ERR_PROTO`\n - :macro:`NGTCP2_ERR_VERSION_NEGOTIATION_FAILURE`\n - :macro:`NGTCP2_ERR_NOMEM`\n - :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n\n If the other value is returned, it is treated as\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`.\n\n If application encounters fatal error, return\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library call\n return immediately."]
pub type ngtcp2_recv_crypto_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        encryption_level: ngtcp2_encryption_level,
        offset: u64,
        data: *const u8,
        datalen: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_handshake_completed` is invoked when QUIC\n cryptographic handshake has completed.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_handshake_completed = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_handshake_confirmed` is invoked when QUIC\n cryptographic handshake is confirmed.  The handshake confirmation\n means that both endpoints agree that handshake has finished.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_handshake_confirmed = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_version_negotiation` is invoked when Version\n Negotiation packet is received.  |hd| is the pointer to the QUIC\n packet header object.  The vector |sv| of |nsv| elements contains\n the QUIC version the server supports.  Since Version Negotiation is\n only sent by server, this callback function is used by client only.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library call\n return immediately."]
pub type ngtcp2_recv_version_negotiation = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        hd: *const ngtcp2_pkt_hd,
        sv: *const u32,
        nsv: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_retry` is invoked when Retry packet is received.\n This callback is client use only.\n\n Application must regenerate packet protection key, IV, and header\n protection key for Initial packets using the Destination Connection\n ID obtained by :member:`hd->scid <ngtcp2_pkt_hd.scid>`, and install\n them by calling `ngtcp2_conn_install_initial_key`.\n\n 0-RTT data accepted by the ngtcp2 library will be automatically\n retransmitted as 0-RTT data by the library.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_recv_retry = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        hd: *const ngtcp2_pkt_hd,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_encrypt` is invoked when the ngtcp2 library asks the\n application to encrypt packet payload.  The packet payload to\n encrypt is passed as |plaintext| of length |plaintextlen|.  The\n AEAD cipher is |aead|.  |aead_ctx| is the AEAD cipher context\n object which is initialized with the specific encryption key.  The\n nonce is passed as |nonce| of length |noncelen|.  The Additional\n Authenticated Data is passed as |aad| of length |aadlen|.\n\n The implementation of this callback must encrypt |plaintext| using\n the negotiated cipher suite, and write the ciphertext into the\n buffer pointed by |dest|.  |dest| has enough capacity to store the\n ciphertext and any additional AEAD tag data.\n\n |dest| and |plaintext| may point to the same buffer.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library call\n return immediately."]
pub type ngtcp2_encrypt = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut u8,
        aead: *const ngtcp2_crypto_aead,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        plaintext: *const u8,
        plaintextlen: usize,
        nonce: *const u8,
        noncelen: usize,
        aad: *const u8,
        aadlen: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_decrypt` is invoked when the ngtcp2 library asks the\n application to decrypt packet payload.  The packet payload to\n decrypt is passed as |ciphertext| of length |ciphertextlen|.  The\n AEAD cipher is |aead|.  |aead_ctx| is the AEAD cipher context\n object which is initialized with the specific decryption key.  The\n nonce is passed as |nonce| of length |noncelen|.  The Additional\n Authenticated Data is passed as |aad| of length |aadlen|.\n\n The implementation of this callback must decrypt |ciphertext| using\n the negotiated cipher suite, and write the ciphertext into the\n buffer pointed by |dest|.  |dest| has enough capacity to store the\n cleartext.\n\n |dest| and |ciphertext| may point to the same buffer.\n\n The callback function must return 0 if it succeeds.  If TLS stack\n fails to decrypt data, return :macro:`NGTCP2_ERR_DECRYPT`.  For any\n other errors, return :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which\n makes the library call return immediately."]
pub type ngtcp2_decrypt = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut u8,
        aead: *const ngtcp2_crypto_aead,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        ciphertext: *const u8,
        ciphertextlen: usize,
        nonce: *const u8,
        noncelen: usize,
        aad: *const u8,
        aadlen: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_hp_mask` is invoked when the ngtcp2 library asks the\n application to produce a mask to encrypt or decrypt packet header.\n The encryption cipher is |hp|.  |hp_ctx| is the cipher context\n object which is initialized with the specific header protection\n key.  The sample is passed as |sample| which is\n :macro:`NGTCP2_HP_SAMPLELEN` bytes long.\n\n The implementation of this callback must produce a mask using the\n header protection cipher suite specified by QUIC specification, and\n write the result into the buffer pointed by |dest|.  The length of\n the mask must be at least :macro:`NGTCP2_HP_MASKLEN`.  The library\n only uses the first :macro:`NGTCP2_HP_MASKLEN` bytes of the\n produced mask.  The buffer pointed by |dest| is guaranteed to have\n at least :macro:`NGTCP2_HP_SAMPLELEN` bytes available for\n convenience.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library call\n return immediately."]
pub type ngtcp2_hp_mask = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut u8,
        hp: *const ngtcp2_crypto_cipher,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
        sample: *const u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_stream_data` is invoked when stream data is\n received.  The stream is specified by |stream_id|.  |flags| is the\n bitwise-OR of zero or more of :macro:`NGTCP2_STREAM_DATA_FLAG_*\n <NGTCP2_STREAM_DATA_FLAG_NONE>`.  If |flags| &\n :macro:`NGTCP2_STREAM_DATA_FLAG_FIN` is nonzero, this portion of\n the data is the last data in this stream.  |offset| is the offset\n where this data begins.  The library ensures that data is passed to\n the application in the non-decreasing order of |offset| without any\n overlap.  The data is passed as |data| of length |datalen|.\n |datalen| may be 0 if and only if |fin| is nonzero.\n\n If :macro:`NGTCP2_STREAM_DATA_FLAG_0RTT` is set in |flags|, it\n indicates that a part of or whole data was received in 0-RTT\n packet, and a handshake has not completed yet.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library return\n immediately."]
pub type ngtcp2_recv_stream_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        flags: u32,
        stream_id: i64,
        offset: u64,
        data: *const u8,
        datalen: usize,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_stream_open` is a callback function which is called\n when remote stream is opened by a remote endpoint.  This function\n is not called if stream is opened by implicitly (we might\n reconsider this behaviour later).\n\n The implementation of this callback should return 0 if it succeeds.\n Returning :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library\n call return immediately."]
pub type ngtcp2_stream_open = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_stream_close` is invoked when a stream is closed.\n This callback is not called when QUIC connection is closed before\n existing streams are closed.  |flags| is the bitwise-OR of zero or\n more of :macro:`NGTCP2_STREAM_CLOSE_FLAG_*\n <NGTCP2_STREAM_CLOSE_FLAG_NONE>`.  |app_error_code| indicates the\n error code of this closure if\n :macro:`NGTCP2_STREAM_CLOSE_FLAG_APP_ERROR_CODE_SET` is set in\n |flags|.  If it is not set, the stream was closed without any error\n code, which generally means success.\n\n |app_error_code| is the first application error code sent by a\n local endpoint, or received from a remote endpoint.  If a stream is\n closed cleanly, no application error code is exchanged.  Since QUIC\n stack does not know the application error code which indicates \"no\n errors\", |app_error_code| is set to 0 and\n :macro:`NGTCP2_STREAM_CLOSE_FLAG_APP_ERROR_CODE_SET` is not set in\n |flags| in this case.\n\n The implementation of this callback should return 0 if it succeeds.\n Returning :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library\n call return immediately."]
pub type ngtcp2_stream_close = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        flags: u32,
        stream_id: i64,
        app_error_code: u64,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_stream_reset` is invoked when a stream identified by\n |stream_id| is reset by a remote endpoint.\n\n The implementation of this callback should return 0 if it succeeds.\n Returning :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library\n call return immediately."]
pub type ngtcp2_stream_reset = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        final_size: u64,
        app_error_code: u64,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_acked_stream_data_offset` is a callback function\n which is called when stream data in range [|offset|, |offset| +\n |datalen|) is acknowledged, and application can free the portion of\n data.  For a given |stream_id|, this callback is called\n sequentially in increasing order of |offset| without any overlap.\n |datalen| is normally strictly greater than 0.  One exception is\n that when a STREAM frame has fin flag set and 0 length data, this\n callback is invoked with |datalen| == 0.\n\n If a stream is closed prematurely, and stream data is still\n in-flight, this callback function is not called for those data.\n After :member:`ngtcp2_callbacks.stream_close` is called for a\n particular stream, |conn| does not touch data for the closed stream\n again, and application can free all unacknowledged stream data.\n\n The implementation of this callback should return 0 if it succeeds.\n Returning :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library\n call return immediately."]
pub type ngtcp2_acked_stream_data_offset = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        offset: u64,
        datalen: u64,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_stateless_reset` is a callback function which is\n called when Stateless Reset packet is received.  The stateless\n reset details are given in |sr|.\n\n The implementation of this callback should return 0 if it succeeds.\n Returning :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library\n call return immediately."]
pub type ngtcp2_recv_stateless_reset = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        sr: *const ngtcp2_pkt_stateless_reset,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_extend_max_streams` is a callback function which is\n called every time max stream ID is strictly extended.\n |max_streams| is the cumulative number of streams which an endpoint\n can open.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_extend_max_streams = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        max_streams: u64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_extend_max_stream_data` is a callback function which\n is invoked when max stream data is extended.  |stream_id|\n identifies the stream.  |max_data| is a cumulative number of bytes\n an endpoint can send on this stream.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_extend_max_stream_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        max_data: u64,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_rand` is a callback function to get random data of\n length |destlen|.  Application must fill random |destlen| bytes to\n the buffer pointed by |dest|.  The generated data is used only in\n non-cryptographic context.  But it is strongly recommended to use a\n secure random number generator."]
pub type ngtcp2_rand = ::std::option::Option<
    unsafe extern "C" fn(dest: *mut u8, destlen: usize, rand_ctx: *const ngtcp2_rand_ctx),
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_get_new_connection_id` is a callback function to ask\n an application for new connection ID.  Application must generate\n new unused connection ID with the exact |cidlen| bytes, and store\n it in |cid|.  It also has to generate a stateless reset token, and\n store it in |token|.  The length of stateless reset token is\n :macro:`NGTCP2_STATELESS_RESET_TOKENLEN` and it is guaranteed that\n the buffer pointed by |token| has the sufficient space to store the\n token.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_get_new_connection_id = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        cid: *mut ngtcp2_cid,
        token: *mut u8,
        cidlen: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_remove_connection_id` is a callback function which\n notifies the application that connection ID |cid| is no longer used\n by a remote endpoint.  This Connection ID was previously offered by\n a local endpoint, and a remote endpoint could use it as Destination\n Connection ID when sending QUIC packet.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_remove_connection_id = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        cid: *const ngtcp2_cid,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_update_key` is a callback function which tells the\n application that it must generate new packet protection keying\n materials and AEAD cipher context objects with new keys.  The\n current set of secrets are given as |current_rx_secret| and\n |current_tx_secret| of length |secretlen|.  They are decryption and\n encryption secrets respectively.\n\n The application must generate new secrets and keys for both\n encryption and decryption.  It must write decryption secret and IV\n to the buffer pointed by |rx_secret| and |rx_iv| respectively.  It\n also must create new AEAD cipher context object with new decryption\n key and initialize |rx_aead_ctx| with it.  Similarly, write\n encryption secret and IV to the buffer pointed by |tx_secret| and\n |tx_iv|.  Create new AEAD cipher context object with new encryption\n key and initialize |tx_aead_ctx| with it.  All given buffers have\n the enough capacity to store secret, key and IV.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_update_key = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        rx_secret: *mut u8,
        tx_secret: *mut u8,
        rx_aead_ctx: *mut ngtcp2_crypto_aead_ctx,
        rx_iv: *mut u8,
        tx_aead_ctx: *mut ngtcp2_crypto_aead_ctx,
        tx_iv: *mut u8,
        current_rx_secret: *const u8,
        current_tx_secret: *const u8,
        secretlen: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_begin_path_validation` is a callback function which\n is called when the path validation has started.  |flags| is zero or\n more of :macro:`NGTCP2_PATH_VALIDATION_FLAG_*\n <NGTCP2_PATH_VALIDATION_FLAG_NONE>`.  |path| is the path that is\n being validated.  |fallback_path|, if not NULL, is the path that is\n used when this validation fails.\n\n Currently, the flags may only contain\n :macro:`NGTCP2_PATH_VALIDATION_FLAG_PREFERRED_ADDR`.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_begin_path_validation = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        flags: u32,
        path: *const ngtcp2_path,
        fallback_path: *const ngtcp2_path,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_path_validation` is a callback function which tells\n an application the outcome of path validation.  |flags| is zero or\n more of :macro:`NGTCP2_PATH_VALIDATION_FLAG_*\n <NGTCP2_PATH_VALIDATION_FLAG_NONE>`.  |path| is the path that was\n validated.  |fallback_path|, if not NULL, is the path that is used\n if the path validation failed.  If |res| is\n :enum:`ngtcp2_path_validation_result.NGTCP2_PATH_VALIDATION_RESULT_SUCCESS`,\n the path validation succeeded.  If |res| is\n :enum:`ngtcp2_path_validation_result.NGTCP2_PATH_VALIDATION_RESULT_FAILURE`,\n the path validation failed.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_path_validation = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        flags: u32,
        path: *const ngtcp2_path,
        fallback_path: *const ngtcp2_path,
        res: ngtcp2_path_validation_result,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_select_preferred_addr` is a callback function which\n asks a client application to choose server address from preferred\n addresses |paddr| received from server.  An application should\n write a network path for a selected preferred address in |dest|.\n More specifically, the selected preferred address must be set to\n :member:`dest->remote <ngtcp2_path.remote>`, a client source\n address must be set to :member:`dest->local <ngtcp2_path.local>`.\n If a client source address does not change for the new server\n address, leave :member:`dest->local <ngtcp2_path.local>`\n unmodified, or copy the value of :member:`local\n <ngtcp2_path.local>` field of the current network path obtained\n from `ngtcp2_conn_get_path()`.  Both :member:`dest->local.addr\n <ngtcp2_addr.addr>` and :member:`dest->remote.addr\n <ngtcp2_addr.addr>` point to buffers which are at least\n sizeof(:type:`ngtcp2_sockaddr_union`) bytes long, respectively.  If\n an application denies the preferred addresses, just leave |dest|\n unmodified (or set :member:`dest->remote.addrlen\n <ngtcp2_addr.addrlen>` to 0), and return 0.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_select_preferred_addr = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        dest: *mut ngtcp2_path,
        paddr: *const ngtcp2_preferred_addr,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " :enum:`NGTCP2_CONNECTION_ID_STATUS_TYPE_ACTIVATE` indicates that\n a local endpoint starts using new Destination Connection ID."]
pub const NGTCP2_CONNECTION_ID_STATUS_TYPE_ACTIVATE: ngtcp2_connection_id_status_type = 0;
#[doc = " :enum:`NGTCP2_CONNECTION_ID_STATUS_TYPE_DEACTIVATE` indicates\n that a local endpoint stops using a given Destination Connection\n ID."]
pub const NGTCP2_CONNECTION_ID_STATUS_TYPE_DEACTIVATE: ngtcp2_connection_id_status_type = 1;
#[doc = " @enum\n\n :type:`ngtcp2_connection_id_status_type` defines a set of status\n for Destination Connection ID."]
pub type ngtcp2_connection_id_status_type = ::std::os::raw::c_uint;
#[doc = " @functypedef\n\n :type:`ngtcp2_connection_id_status` is a callback function which is\n called when the status of Destination Connection ID changes.\n\n |token| is the associated stateless reset token, and it is ``NULL``\n if no token is present.\n\n |type| is the one of the value defined in\n :type:`ngtcp2_connection_id_status_type`.  The new value might be\n added in the future release.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_connection_id_status = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        type_: ngtcp2_connection_id_status_type,
        seq: u64,
        cid: *const ngtcp2_cid,
        token: *const u8,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_new_token` is a callback function which is\n called when new token is received from server.  This callback is\n client use only.\n\n |token| is the received token of length |tokenlen| bytes long.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_recv_new_token = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        token: *const u8,
        tokenlen: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_delete_crypto_aead_ctx` is a callback function which\n must delete the native object pointed by\n :member:`aead_ctx->native_handle\n <ngtcp2_crypto_aead_ctx.native_handle>`."]
pub type ngtcp2_delete_crypto_aead_ctx = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        aead_ctx: *mut ngtcp2_crypto_aead_ctx,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_delete_crypto_cipher_ctx` is a callback function\n which must delete the native object pointed by\n :member:`cipher_ctx->native_handle\n <ngtcp2_crypto_cipher_ctx.native_handle>`."]
pub type ngtcp2_delete_crypto_cipher_ctx = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        cipher_ctx: *mut ngtcp2_crypto_cipher_ctx,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_datagram` is invoked when DATAGRAM frame is\n received.  |flags| is bitwise-OR of zero or more of\n :macro:`NGTCP2_DATAGRAM_FLAG_* <NGTCP2_DATAGRAM_FLAG_NONE>`.\n\n If :macro:`NGTCP2_DATAGRAM_FLAG_0RTT` is set in |flags|, it\n indicates that DATAGRAM frame was received in 0-RTT packet, and a\n handshake has not completed yet.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library return\n immediately."]
pub type ngtcp2_recv_datagram = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        flags: u32,
        data: *const u8,
        datalen: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_ack_datagram` is invoked when a packet which contains\n DATAGRAM frame which is identified by |dgram_id| is acknowledged.\n |dgram_id| is the valued passed to `ngtcp2_conn_writev_datagram`.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library return\n immediately."]
pub type ngtcp2_ack_datagram = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        dgram_id: u64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_lost_datagram` is invoked when a packet which\n contains DATAGRAM frame which is identified by |dgram_id| is\n declared lost.  |dgram_id| is the valued passed to\n `ngtcp2_conn_writev_datagram`.  Note that the loss might be\n spurious, and DATAGRAM frame might be acknowledged later.\n\n The callback function must return 0 if it succeeds, or\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` which makes the library return\n immediately."]
pub type ngtcp2_lost_datagram = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        dgram_id: u64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_get_path_challenge_data` is a callback function to\n ask an application for new data that is sent in PATH_CHALLENGE\n frame.  Application must generate new unpredictable, exactly\n :macro:`NGTCP2_PATH_CHALLENGE_DATALEN` bytes of random data, and\n store them into the buffer pointed by |data|.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_get_path_challenge_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        data: *mut u8,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_stream_stop_sending` is invoked when a stream is no\n longer read by a local endpoint before it receives all stream data.\n This function is called at most once per stream.  |app_error_code|\n is the error code passed to `ngtcp2_conn_shutdown_stream_read` or\n `ngtcp2_conn_shutdown_stream`.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_stream_stop_sending = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        app_error_code: u64,
        user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_version_negotiation` is invoked when the compatible\n version negotiation takes place.  For client, it is called when it\n sees a change in version field of a long header packet.  This\n callback function might be called multiple times for client.  For\n server, it is called once when the version is negotiated.\n\n The implementation of this callback must install new Initial keys\n for |version| and Destination Connection ID |client_dcid| from\n client.  Use `ngtcp2_conn_install_vneg_initial_key` to install\n keys.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_version_negotiation = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        version: u32,
        client_dcid: *const ngtcp2_cid,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_recv_key` is invoked when new key is installed to\n |conn| during QUIC cryptographic handshake.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_recv_key = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        level: ngtcp2_encryption_level,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`ngtcp2_tls_early_data_rejected` is invoked when early data\n was rejected by server during TLS handshake, or client decided not\n to attempt early data.\n\n The callback function must return 0 if it succeeds.  Returning\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE` makes the library call return\n immediately."]
pub type ngtcp2_tls_early_data_rejected = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @struct\n\n :type:`ngtcp2_callbacks` holds a set of callback functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_callbacks {
    #[doc = " :member:`client_initial` is a callback function which is invoked\n when client asks TLS stack to produce first TLS cryptographic\n handshake message.  This callback function must be specified for\n a client application."]
    pub client_initial: ngtcp2_client_initial,
    #[doc = " :member:`recv_client_initial` is a callback function which is\n invoked when a server receives the first Initial packet from\n client.  This callback function must be specified for a server\n application."]
    pub recv_client_initial: ngtcp2_recv_client_initial,
    #[doc = " :member:`recv_crypto_data` is a callback function which is\n invoked when cryptographic data (CRYPTO frame, in other words,\n TLS message) is received.  This callback function must be\n specified."]
    pub recv_crypto_data: ngtcp2_recv_crypto_data,
    #[doc = " :member:`handshake_completed` is a callback function which is\n invoked when QUIC cryptographic handshake has completed.  This\n callback function is optional."]
    pub handshake_completed: ngtcp2_handshake_completed,
    #[doc = " :member:`recv_version_negotiation` is a callback function which\n is invoked when Version Negotiation packet is received by a\n client.  This callback function is optional."]
    pub recv_version_negotiation: ngtcp2_recv_version_negotiation,
    #[doc = " :member:`encrypt` is a callback function which is invoked to\n encrypt a QUIC packet.  This callback function must be specified."]
    pub encrypt: ngtcp2_encrypt,
    #[doc = " :member:`decrypt` is a callback function which is invoked to\n decrypt a QUIC packet.  This callback function must be specified."]
    pub decrypt: ngtcp2_decrypt,
    #[doc = " :member:`hp_mask` is a callback function which is invoked to get\n a mask to encrypt or decrypt QUIC packet header.  This callback\n function must be specified."]
    pub hp_mask: ngtcp2_hp_mask,
    #[doc = " :member:`recv_stream_data` is a callback function which is\n invoked when stream data, which includes application data, is\n received.  This callback function is optional."]
    pub recv_stream_data: ngtcp2_recv_stream_data,
    #[doc = " :member:`acked_stream_data_offset` is a callback function which\n is invoked when stream data, which includes application data, is\n acknowledged by a remote endpoint.  It tells an application the\n largest offset of acknowledged stream data without a gap so that\n application can free memory for the data up to that offset.  This\n callback function is optional."]
    pub acked_stream_data_offset: ngtcp2_acked_stream_data_offset,
    #[doc = " :member:`stream_open` is a callback function which is invoked\n when new remote stream is opened by a remote endpoint.  This\n callback function is optional."]
    pub stream_open: ngtcp2_stream_open,
    #[doc = " :member:`stream_close` is a callback function which is invoked\n when a stream is closed.  This callback function is optional."]
    pub stream_close: ngtcp2_stream_close,
    #[doc = " :member:`recv_stateless_reset` is a callback function which is\n invoked when Stateless Reset packet is received.  This callback\n function is optional."]
    pub recv_stateless_reset: ngtcp2_recv_stateless_reset,
    #[doc = " :member:`recv_retry` is a callback function which is invoked when\n a client receives Retry packet.  For client, this callback\n function must be specified.  Server never receive Retry packet."]
    pub recv_retry: ngtcp2_recv_retry,
    #[doc = " :member:`extend_max_local_streams_bidi` is a callback function\n which is invoked when the number of bidirectional stream which a\n local endpoint can open is increased.  This callback function is\n optional."]
    pub extend_max_local_streams_bidi: ngtcp2_extend_max_streams,
    #[doc = " :member:`extend_max_local_streams_uni` is a callback function\n which is invoked when the number of unidirectional stream which a\n local endpoint can open is increased.  This callback function is\n optional."]
    pub extend_max_local_streams_uni: ngtcp2_extend_max_streams,
    #[doc = " :member:`rand` is a callback function which is invoked when the\n library needs random data.  This callback function must be\n specified."]
    pub rand: ngtcp2_rand,
    #[doc = " :member:`get_new_connection_id` is a callback function which is\n invoked when the library needs new connection ID.  This callback\n function must be specified."]
    pub get_new_connection_id: ngtcp2_get_new_connection_id,
    #[doc = " :member:`remove_connection_id` is a callback function which\n notifies an application that connection ID is no longer used by a\n remote endpoint.  This callback function is optional."]
    pub remove_connection_id: ngtcp2_remove_connection_id,
    #[doc = " :member:`update_key` is a callback function which is invoked when\n the library tells an application that it must update keying\n materials, and install new keys.  This callback function must be\n specified."]
    pub update_key: ngtcp2_update_key,
    #[doc = " :member:`path_validation` is a callback function which is invoked\n when path validation completed.  This callback function is\n optional."]
    pub path_validation: ngtcp2_path_validation,
    #[doc = " :member:`select_preferred_addr` is a callback function which is\n invoked when the library asks a client to select preferred\n address presented by a server.  If not set, client ignores\n preferred addresses.  This callback function is optional."]
    pub select_preferred_addr: ngtcp2_select_preferred_addr,
    #[doc = " :member:`stream_reset` is a callback function which is invoked\n when a stream is reset by a remote endpoint.  This callback\n function is optional."]
    pub stream_reset: ngtcp2_stream_reset,
    #[doc = " :member:`extend_max_remote_streams_bidi` is a callback function\n which is invoked when the number of bidirectional streams which a\n remote endpoint can open is increased.  This callback function is\n optional."]
    pub extend_max_remote_streams_bidi: ngtcp2_extend_max_streams,
    #[doc = " :member:`extend_max_remote_streams_uni` is a callback function\n which is invoked when the number of unidirectional streams which\n a remote endpoint can open is increased.  This callback function\n is optional."]
    pub extend_max_remote_streams_uni: ngtcp2_extend_max_streams,
    #[doc = " :member:`extend_max_stream_data` is callback function which is\n invoked when the maximum offset of stream data that a local\n endpoint can send is increased.  This callback function is\n optional."]
    pub extend_max_stream_data: ngtcp2_extend_max_stream_data,
    #[doc = " :member:`dcid_status` is a callback function which is invoked\n when the new Destination Connection ID is activated, or the\n activated Destination Connection ID is now deactivated.  This\n callback function is optional."]
    pub dcid_status: ngtcp2_connection_id_status,
    #[doc = " :member:`handshake_confirmed` is a callback function which is\n invoked when both endpoints agree that handshake has finished.\n This field is ignored by server because\n :member:`handshake_completed` also indicates the handshake\n confirmation for server.  This callback function is optional."]
    pub handshake_confirmed: ngtcp2_handshake_confirmed,
    #[doc = " :member:`recv_new_token` is a callback function which is invoked\n when new token is received from server.  This field is ignored by\n server.  This callback function is optional."]
    pub recv_new_token: ngtcp2_recv_new_token,
    #[doc = " :member:`delete_crypto_aead_ctx` is a callback function which\n deletes a given AEAD cipher context object.  This callback\n function must be specified."]
    pub delete_crypto_aead_ctx: ngtcp2_delete_crypto_aead_ctx,
    #[doc = " :member:`delete_crypto_cipher_ctx` is a callback function which\n deletes a given cipher context object.  This callback function\n must be specified."]
    pub delete_crypto_cipher_ctx: ngtcp2_delete_crypto_cipher_ctx,
    #[doc = " :member:`recv_datagram` is a callback function which is invoked\n when DATAGRAM frame is received.  This callback function is\n optional."]
    pub recv_datagram: ngtcp2_recv_datagram,
    #[doc = " :member:`ack_datagram` is a callback function which is invoked\n when a QUIC packet containing DATAGRAM frame is acknowledged by a\n remote endpoint.  This callback function is optional."]
    pub ack_datagram: ngtcp2_ack_datagram,
    #[doc = " :member:`lost_datagram` is a callback function which is invoked\n when a QUIC packet containing DATAGRAM frame is declared lost.\n This callback function is optional."]
    pub lost_datagram: ngtcp2_lost_datagram,
    #[doc = " :member:`get_path_challenge_data` is a callback function which is\n invoked when the library needs new data sent along with\n PATH_CHALLENGE frame.  This callback must be specified."]
    pub get_path_challenge_data: ngtcp2_get_path_challenge_data,
    #[doc = " :member:`stream_stop_sending` is a callback function which is\n invoked when a local endpoint no longer reads from a stream\n before it receives all stream data.  This callback function is\n optional."]
    pub stream_stop_sending: ngtcp2_stream_stop_sending,
    #[doc = " :member:`version_negotiation` is a callback function which is\n invoked when the compatible version negotiation takes place.\n This callback function must be specified."]
    pub version_negotiation: ngtcp2_version_negotiation,
    #[doc = " :member:`recv_rx_key` is a callback function which is invoked\n when a new key for decrypting packets is installed during QUIC\n cryptographic handshake.  It is not called for\n :enum:`ngtcp2_encryption_level.NGTCP2_ENCRYPTION_LEVEL_INITIAL`."]
    pub recv_rx_key: ngtcp2_recv_key,
    #[doc = " :member:`recv_tx_key` is a callback function which is invoked\n when a new key for encrypting packets is installed during QUIC\n cryptographic handshake.  It is not called for\n :enum:`ngtcp2_encryption_level.NGTCP2_ENCRYPTION_LEVEL_INITIAL`."]
    pub recv_tx_key: ngtcp2_recv_key,
    #[doc = " :member:`tls_early_data_rejected` is a callback function which is\n invoked when server rejected early data during TLS handshake, or\n client decided not to attempt early data.  This callback function\n is only used by client."]
    pub tls_early_data_rejected: ngtcp2_tls_early_data_rejected,
    #[doc = " :member:`begin_path_validation` is a callback function which is\n invoked when a path validation has started.  This field is\n available since v1.14.0."]
    pub begin_path_validation: ngtcp2_begin_path_validation,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_write_connection_close` writes Initial packet\n containing CONNECTION_CLOSE frame with the given |error_code| and\n the optional |reason| of length |reasonlen| to the buffer pointed\n by |dest| of length |destlen|.  All encryption parameters are for\n Initial packet encryption.  The packet number is always 0.\n\n The primary use case of this function is for server to send\n CONNECTION_CLOSE frame in Initial packet to close connection\n without committing any state when validating Retry token fails.\n\n This function returns the number of bytes written if it succeeds,\n or one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     Callback function failed."]
    pub fn ngtcp2_pkt_write_connection_close(
        dest: *mut u8,
        destlen: usize,
        version: u32,
        dcid: *const ngtcp2_cid,
        scid: *const ngtcp2_cid,
        error_code: u64,
        reason: *const u8,
        reasonlen: usize,
        encrypt: ngtcp2_encrypt,
        aead: *const ngtcp2_crypto_aead,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        hp_mask: ngtcp2_hp_mask,
        hp: *const ngtcp2_crypto_cipher,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_pkt_write_retry` writes Retry packet in the buffer pointed\n by |dest| whose length is |destlen|.  |dcid| is the Connection ID\n which appeared in a packet as a Source Connection ID sent by\n client.  |scid| is a server chosen Source Connection ID.  |odcid|\n specifies Original Destination Connection ID which appeared in a\n packet as a Destination Connection ID sent by client.  |token|\n specifies Retry Token, and |tokenlen| specifies its length.  |aead|\n must be AEAD_AES_128_GCM.  |aead_ctx| must be initialized with\n :macro:`NGTCP2_RETRY_KEY` as an encryption key.\n\n This function returns the number of bytes written to the buffer, or\n one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     Callback function failed.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     :member:`odcid->datalen <ngtcp2_cid.datalen>` is less than\n     :macro:`NGTCP2_MIN_INITIAL_DCIDLEN`."]
    pub fn ngtcp2_pkt_write_retry(
        dest: *mut u8,
        destlen: usize,
        version: u32,
        dcid: *const ngtcp2_cid,
        scid: *const ngtcp2_cid,
        odcid: *const ngtcp2_cid,
        token: *const u8,
        tokenlen: usize,
        encrypt: ngtcp2_encrypt,
        aead: *const ngtcp2_crypto_aead,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_accept` is used by server implementation, and decides\n whether packet |pkt| of length |pktlen| from client is acceptable\n for the very first packet to a connection.\n\n If |dest| is not ``NULL`` and the function returns 0, the decoded\n packet header is stored in the object pointed by |dest|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     The packet is not acceptable for the very first packet to a new\n     connection; or the function failed to parse the packet header."]
    pub fn ngtcp2_accept(
        dest: *mut ngtcp2_pkt_hd,
        pkt: *const u8,
        pktlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_client_new` creates new :type:`ngtcp2_conn`, and\n initializes it as client.  On success, it stores the pointer to the\n newly allocated object in |*pconn|.  |dcid| is a randomized\n Destination Connection ID which must be longer than or equal to\n :macro:`NGTCP2_MIN_INITIAL_DCIDLEN`.  |scid| is a Source Connection\n ID chosen by client.  |client_chosen_version| is a QUIC version\n that a client chooses.  |path| is the network path where this QUIC\n connection is being established, and must not be ``NULL``.\n |callbacks|, |settings|, and |params| must not be ``NULL``, and the\n function makes a copy of each of them.  |params| is a local QUIC\n transport parameters, and sent to a remote endpoint during\n handshake.  |user_data| is the arbitrary pointer which is passed to\n the user-defined callback functions.  If |mem| is ``NULL``, the\n memory allocator returned by `ngtcp2_mem_default()` is used.\n\n Call `ngtcp2_conn_del` to free memory allocated for |*pconn|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_client_new_versioned(
        pconn: *mut *mut ngtcp2_conn,
        dcid: *const ngtcp2_cid,
        scid: *const ngtcp2_cid,
        path: *const ngtcp2_path,
        client_chosen_version: u32,
        callbacks_version: ::std::os::raw::c_int,
        callbacks: *const ngtcp2_callbacks,
        settings_version: ::std::os::raw::c_int,
        settings: *const ngtcp2_settings,
        transport_params_version: ::std::os::raw::c_int,
        params: *const ngtcp2_transport_params,
        mem: *const ngtcp2_mem,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_server_new` creates new :type:`ngtcp2_conn`, and\n initializes it as server.  On success, it stores the pointer to the\n newly allocated object in |*pconn|.  |dcid| is a Destination\n Connection ID, and is usually the Connection ID that appears in\n client Initial packet as Source Connection ID.  |scid| is a Source\n Connection ID chosen by server.  |path| is the network path where\n this QUIC connection is being established, and must not be\n ``NULL``.  |client_chosen_version| is a QUIC version that a client\n chooses.  |callbacks|, |settings|, and |params| must not be\n ``NULL``, and the function makes a copy of each of them.  |params|\n is a local QUIC transport parameters, and sent to a remote endpoint\n during handshake.  |user_data| is the arbitrary pointer which is\n passed to the user-defined callback functions.  If |mem| is\n ``NULL``, the memory allocator returned by `ngtcp2_mem_default()`\n is used.\n\n Call `ngtcp2_conn_del` to free memory allocated for |*pconn|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_server_new_versioned(
        pconn: *mut *mut ngtcp2_conn,
        dcid: *const ngtcp2_cid,
        scid: *const ngtcp2_cid,
        path: *const ngtcp2_path,
        client_chosen_version: u32,
        callbacks_version: ::std::os::raw::c_int,
        callbacks: *const ngtcp2_callbacks,
        settings_version: ::std::os::raw::c_int,
        settings: *const ngtcp2_settings,
        transport_params_version: ::std::os::raw::c_int,
        params: *const ngtcp2_transport_params,
        mem: *const ngtcp2_mem,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_del` frees resources allocated for |conn|.  It also\n frees memory pointed by |conn|."]
    pub fn ngtcp2_conn_del(conn: *mut ngtcp2_conn);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_read_pkt` decrypts QUIC packet given in |pkt| of\n length |pktlen| and processes it.  |path| is the network path the\n packet is delivered and must not be ``NULL``.  |pi| is packet\n metadata and may be ``NULL``. This function performs QUIC handshake\n as well.\n\n This function must not be called from inside the callback\n functions.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_RETRY`\n    Server must perform address validation by sending Retry packet\n    (see `ngtcp2_crypto_write_retry` and `ngtcp2_pkt_write_retry`),\n    and discard the connection state.  Client application does not\n    get this error code.\n :macro:`NGTCP2_ERR_DROP_CONN`\n    Server application must drop the connection silently (without\n    sending any CONNECTION_CLOSE frame), and discard connection\n    state.  Client application does not get this error code.\n :macro:`NGTCP2_ERR_DRAINING`\n    A connection has entered the draining state, and no further\n    packet transmission is allowed.\n :macro:`NGTCP2_ERR_CLOSING`\n    A connection has entered the closing state, and no further\n    packet transmission is allowed.  Calling\n    `ngtcp2_conn_write_connection_close` makes a connection enter\n    this state.\n :macro:`NGTCP2_ERR_CRYPTO`\n    An error happened in TLS stack.  `ngtcp2_conn_get_tls_alert`\n    returns TLS alert if set.\n\n If any other negative error is returned, call\n `ngtcp2_conn_write_connection_close` to get terminal packet, and\n sending it makes QUIC connection enter the closing state."]
    pub fn ngtcp2_conn_read_pkt_versioned(
        conn: *mut ngtcp2_conn,
        path: *const ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *const ngtcp2_pkt_info,
        pkt: *const u8,
        pktlen: usize,
        ts: ngtcp2_tstamp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_write_pkt` is equivalent to calling\n `ngtcp2_conn_writev_stream` with -1 as |stream_id|, no stream data,\n and :macro:`NGTCP2_WRITE_STREAM_FLAG_NONE` as flags."]
    pub fn ngtcp2_conn_write_pkt_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_tls_handshake_completed` tells |conn| that the TLS\n stack declares TLS handshake completion.  This does not mean QUIC\n handshake has completed.  The library needs extra conditions to be\n met."]
    pub fn ngtcp2_conn_tls_handshake_completed(conn: *mut ngtcp2_conn);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_handshake_completed` returns nonzero if QUIC\n handshake has completed."]
    pub fn ngtcp2_conn_get_handshake_completed(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_initial_key` installs packet protection keying\n materials for Initial packets.  |rx_aead_ctx| is AEAD cipher\n context object, and must be initialized with a decryption key.\n |rx_iv| is IV of length |rx_ivlen| for decryption.  |rx_hp_ctx| is\n a packet header protection cipher context object for decryption.\n Similarly, |tx_aead_ctx|, |tx_iv| and |tx_hp_ctx| are for\n encrypting outgoing packets, and are the same length with the\n decryption counterpart .  If they have already been set, they are\n overwritten.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |rx_aead_ctx|,\n |rx_hp_ctx|, |tx_aead_ctx|, and |tx_hp_ctx|.\n :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n After receiving Retry packet, a Destination Connection ID that\n client sends in Initial packet most likely changes.  In that case,\n client application must generate these keying materials again based\n on new Destination Connection ID, and install them again with this\n function.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_initial_key(
        conn: *mut ngtcp2_conn,
        rx_aead_ctx: *const ngtcp2_crypto_aead_ctx,
        rx_iv: *const u8,
        rx_hp_ctx: *const ngtcp2_crypto_cipher_ctx,
        tx_aead_ctx: *const ngtcp2_crypto_aead_ctx,
        tx_iv: *const u8,
        tx_hp_ctx: *const ngtcp2_crypto_cipher_ctx,
        ivlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_vneg_initial_key` installs packet protection\n keying materials for Initial packets on compatible version\n negotiation for |version|.  |rx_aead_ctx| is AEAD cipher context\n object, and must be initialized with a decryption key.  |rx_iv| is\n IV of length |rx_ivlen| for decryption.  |rx_hp_ctx| is a packet\n header protection cipher context object for decryption.  Similarly,\n |tx_aead_ctx|, |tx_iv| and |tx_hp_ctx| are for encrypting outgoing\n packets, and are the same length with the decryption counterpart.\n If they have already been set, they are overwritten.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |rx_aead_ctx|,\n |rx_hp_ctx|, |tx_aead_ctx|, and |tx_hp_ctx|.\n :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_vneg_initial_key(
        conn: *mut ngtcp2_conn,
        version: u32,
        rx_aead_ctx: *const ngtcp2_crypto_aead_ctx,
        rx_iv: *const u8,
        rx_hp_ctx: *const ngtcp2_crypto_cipher_ctx,
        tx_aead_ctx: *const ngtcp2_crypto_aead_ctx,
        tx_iv: *const u8,
        tx_hp_ctx: *const ngtcp2_crypto_cipher_ctx,
        ivlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_rx_handshake_key` installs packet protection\n keying materials for decrypting incoming Handshake packets.\n |aead_ctx| is AEAD cipher context object which must be initialized\n with a decryption key.  |iv| is IV of length |ivlen|.  |hp_ctx| is\n a packet header protection cipher context object.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |aead_ctx|,\n and |hp_ctx|.  :member:`ngtcp2_callbacks.delete_crypto_aead_ctx`\n and :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be\n called to delete these objects when they are no longer used.  If\n this function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_rx_handshake_key(
        conn: *mut ngtcp2_conn,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        ivlen: usize,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_tx_handshake_key` installs packet protection\n keying materials for encrypting outgoing Handshake packets.\n |aead_ctx| is AEAD cipher context object which must be initialized\n with an encryption key.  |iv| is IV of length |ivlen|.  |hp_ctx| is\n a packet header protection cipher context object.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |aead_ctx| and\n |hp_ctx|.  :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_tx_handshake_key(
        conn: *mut ngtcp2_conn,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        ivlen: usize,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_0rtt_key` installs packet protection AEAD\n cipher context object |aead_ctx|, IV |iv| of length |ivlen|, and\n packet header protection cipher context object |hp_ctx| to encrypt\n (for client) or decrypt (for server) 0-RTT packets.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |aead_ctx| and\n |hp_ctx|.  :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_0rtt_key(
        conn: *mut ngtcp2_conn,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        ivlen: usize,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_rx_key` installs packet protection keying\n materials for decrypting 1-RTT packets.  |secret| of length\n |secretlen| is the decryption secret which is used to derive keying\n materials passed to this function.  |aead_ctx| is AEAD cipher\n context object which must be initialized with a decryption key.\n |iv| is IV of length |ivlen|.  |hp_ctx| is a packet header\n protection cipher context object.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |aead_ctx| and\n |hp_ctx|.  :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_rx_key(
        conn: *mut ngtcp2_conn,
        secret: *const u8,
        secretlen: usize,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        ivlen: usize,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_install_tx_key` installs packet protection keying\n materials for encrypting 1-RTT packets.  |secret| of length\n |secretlen| is the encryption secret which is used to derive keying\n materials passed to this function.  |aead_ctx| is AEAD cipher\n context object which must be initialized with an encryption key.\n |iv| is IV of length |ivlen|.  |hp_ctx| is a packet header\n protection cipher context object.\n\n |ivlen| must be the minimum length of AEAD nonce, or 8 bytes if\n that is larger.\n\n If this function succeeds, |conn| takes ownership of |aead_ctx| and\n |hp_ctx|.  :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` and\n :member:`ngtcp2_callbacks.delete_crypto_cipher_ctx` will be called\n to delete these objects when they are no longer used.  If this\n function fails, the caller is responsible to delete them.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_install_tx_key(
        conn: *mut ngtcp2_conn,
        secret: *const u8,
        secretlen: usize,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
        iv: *const u8,
        ivlen: usize,
        hp_ctx: *const ngtcp2_crypto_cipher_ctx,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_initiate_key_update` initiates the key update.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     The previous key update has not been confirmed yet; or key\n     update is too frequent; or new keys are not available yet."]
    pub fn ngtcp2_conn_initiate_key_update(
        conn: *mut ngtcp2_conn,
        ts: ngtcp2_tstamp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_tls_error` sets the TLS related error |liberr| in\n |conn|.  |liberr| must be one of ngtcp2 library error codes (which\n is defined as NGTCP2_ERR_* macro, such as\n :macro:`NGTCP2_ERR_DECRYPT`).  In general, error code should be\n propagated via return value, but sometimes ngtcp2 API is called\n inside callback function of TLS stack, and it does not allow to\n return ngtcp2 error code directly.  In this case, implementation\n can set the error code (e.g.,\n :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`) using this function.\n\n See also `ngtcp2_conn_get_tls_error`."]
    pub fn ngtcp2_conn_set_tls_error(conn: *mut ngtcp2_conn, liberr: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_tls_error` returns the value set by\n `ngtcp2_conn_set_tls_error`.  If no value is set, this function\n returns 0."]
    pub fn ngtcp2_conn_get_tls_error(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_tls_alert` sets a TLS alert |alert| generated by a\n TLS stack of a local endpoint to |conn|.\n\n See also `ngtcp2_conn_get_tls_alert`."]
    pub fn ngtcp2_conn_set_tls_alert(conn: *mut ngtcp2_conn, alert: u8);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_tls_alert` returns the value set by\n `ngtcp2_conn_set_tls_alert`.  If no value is set, this function\n returns 0."]
    pub fn ngtcp2_conn_get_tls_alert(conn: *mut ngtcp2_conn) -> u8;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_keep_alive_timeout` sets keep-alive timeout.  If\n nonzero value is given, after a connection is idle at least in a\n given amount of time, a keep-alive packet is sent.  If UINT64_MAX\n is set, keep-alive functionality is disabled, and this is the\n default.  Specifying 0 in |timeout| is reserved for a future\n extension, and for now it is treated as if UINT64_MAX is given."]
    pub fn ngtcp2_conn_set_keep_alive_timeout(conn: *mut ngtcp2_conn, timeout: ngtcp2_duration);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_expiry` returns the next expiry time.  It returns\n ``UINT64_MAX`` if there is no next expiry.\n\n Call `ngtcp2_conn_handle_expiry` and then\n `ngtcp2_conn_writev_stream` (or `ngtcp2_conn_writev_datagram`) when\n the expiry time has passed."]
    pub fn ngtcp2_conn_get_expiry(conn: *mut ngtcp2_conn) -> ngtcp2_tstamp;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_handle_expiry` handles expired timer."]
    pub fn ngtcp2_conn_handle_expiry(
        conn: *mut ngtcp2_conn,
        ts: ngtcp2_tstamp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_pto` returns Probe Timeout (PTO)."]
    pub fn ngtcp2_conn_get_pto(conn: *mut ngtcp2_conn) -> ngtcp2_duration;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_decode_and_set_remote_transport_params` decodes QUIC\n transport parameters from the buffer pointed by |data| of length\n |datalen|, and sets the result to |conn|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM`\n     The required parameter is missing.\n :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`\n     The input is malformed.\n :macro:`NGTCP2_ERR_TRANSPORT_PARAM`\n     Failed to validate the remote QUIC transport parameters.\n :macro:`NGTCP2_ERR_VERSION_NEGOTIATION_FAILURE`\n     Version negotiation failure.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     User callback failed"]
    pub fn ngtcp2_conn_decode_and_set_remote_transport_params(
        conn: *mut ngtcp2_conn,
        data: *const u8,
        datalen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_remote_transport_params` returns a pointer to the\n remote QUIC transport parameters.  If no remote transport\n parameters are set, it returns NULL."]
    pub fn ngtcp2_conn_get_remote_transport_params(
        conn: *mut ngtcp2_conn,
    ) -> *const ngtcp2_transport_params;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_encode_0rtt_transport_params` encodes the QUIC\n transport parameters that are used for 0-RTT data in the buffer\n pointed by |dest| of length |destlen|.  It includes at least the\n following fields:\n\n - :member:`ngtcp2_transport_params.initial_max_streams_bidi`\n - :member:`ngtcp2_transport_params.initial_max_streams_uni`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_local`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_remote`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_uni`\n - :member:`ngtcp2_transport_params.initial_max_data`\n - :member:`ngtcp2_transport_params.active_connection_id_limit`\n - :member:`ngtcp2_transport_params.max_datagram_frame_size`\n\n If |conn| is initialized as server, the following additional fields\n are also included:\n\n - :member:`ngtcp2_transport_params.max_idle_timeout`\n - :member:`ngtcp2_transport_params.max_udp_payload_size`\n - :member:`ngtcp2_transport_params.disable_active_migration`\n\n If |conn| is initialized as client, these parameters are\n synthesized from the remote transport parameters received from\n server.  Otherwise, it is the local transport parameters that are\n set by the local endpoint.\n\n This function returns the number of bytes written, or one of the\n following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small."]
    pub fn ngtcp2_conn_encode_0rtt_transport_params(
        conn: *mut ngtcp2_conn,
        dest: *mut u8,
        destlen: usize,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_decode_and_set_0rtt_transport_params` decodes QUIC\n transport parameters from |data| of length |datalen|, which is\n assumed to be the parameters received from the server in the\n previous connection, and sets it to |conn|.  These parameters are\n used to send 0-RTT data.  QUIC requires that client application\n should remember transport parameters along with a session ticket.\n\n At least following fields should be included:\n\n - :member:`ngtcp2_transport_params.initial_max_streams_bidi`\n - :member:`ngtcp2_transport_params.initial_max_streams_uni`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_local`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_bidi_remote`\n - :member:`ngtcp2_transport_params.initial_max_stream_data_uni`\n - :member:`ngtcp2_transport_params.initial_max_data`\n - :member:`ngtcp2_transport_params.active_connection_id_limit`\n - :member:`ngtcp2_transport_params.max_datagram_frame_size` (if\n   DATAGRAM extension was negotiated)\n\n This function must only be used by client.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory.\n :macro:`NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM`\n     The input is malformed."]
    pub fn ngtcp2_conn_decode_and_set_0rtt_transport_params(
        conn: *mut ngtcp2_conn,
        data: *const u8,
        datalen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_local_transport_params` sets the local transport\n parameters |params|.  This function can only be called by server.\n Although the local transport parameters are passed to\n `ngtcp2_conn_server_new`, server might want to update them after\n ALPN is chosen.  In that case, server can update the transport\n parameters with this function.  Server must call this function\n before calling `ngtcp2_conn_install_tx_handshake_key`.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     `ngtcp2_conn_install_tx_handshake_key` has been called."]
    pub fn ngtcp2_conn_set_local_transport_params_versioned(
        conn: *mut ngtcp2_conn,
        transport_params_version: ::std::os::raw::c_int,
        params: *const ngtcp2_transport_params,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_local_transport_params` returns a pointer to the\n local QUIC transport parameters."]
    pub fn ngtcp2_conn_get_local_transport_params(
        conn: *mut ngtcp2_conn,
    ) -> *const ngtcp2_transport_params;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_encode_local_transport_params` encodes the local QUIC\n transport parameters in |dest| of length |destlen|.\n\n This function returns the number of bytes written, or one of the\n following negative error codes:\n\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small."]
    pub fn ngtcp2_conn_encode_local_transport_params(
        conn: *mut ngtcp2_conn,
        dest: *mut u8,
        destlen: usize,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_open_bidi_stream` opens new bidirectional stream.  The\n |stream_user_data| is the user data specific to the stream.  The\n stream ID of the opened stream is stored in |*pstream_id|.\n\n Application can call this function before handshake completes.  For\n 0-RTT packet, application can call this function after calling\n `ngtcp2_conn_decode_and_set_0rtt_transport_params`.  For 1-RTT\n packet, application can call this function after calling\n `ngtcp2_conn_decode_and_set_remote_transport_params` and\n `ngtcp2_conn_install_tx_key`.  If ngtcp2 crypto support library is\n used, application can call this function after calling\n `ngtcp2_crypto_derive_and_install_tx_key` for 1-RTT packet.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_STREAM_ID_BLOCKED`\n     The remote endpoint does not allow |stream_id| yet."]
    pub fn ngtcp2_conn_open_bidi_stream(
        conn: *mut ngtcp2_conn,
        pstream_id: *mut i64,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_open_uni_stream` opens new unidirectional stream.  The\n |stream_user_data| is the user data specific to the stream.  The\n stream ID of the opened stream is stored in |*pstream_id|.\n\n Application can call this function before handshake completes.  For\n 0-RTT packet, application can call this function after calling\n `ngtcp2_conn_decode_and_set_0rtt_transport_params`.  For 1-RTT\n packet, application can call this function after calling\n `ngtcp2_conn_decode_and_set_remote_transport_params` and\n `ngtcp2_conn_install_tx_key`.  If ngtcp2 crypto support library is\n used, application can call this function after calling\n `ngtcp2_crypto_derive_and_install_tx_key` for 1-RTT packet.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_STREAM_ID_BLOCKED`\n     The remote endpoint does not allow |stream_id| yet."]
    pub fn ngtcp2_conn_open_uni_stream(
        conn: *mut ngtcp2_conn,
        pstream_id: *mut i64,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_shutdown_stream` closes a stream denoted by\n |stream_id| abruptly.  |app_error_code| is one of application error\n codes, and indicates the reason of shutdown.  Successful call of\n this function does not immediately erase the state of the stream.\n The actual deletion is done when the remote endpoint sends\n acknowledgement.  Calling this function is equivalent to call\n `ngtcp2_conn_shutdown_stream_read`, and\n `ngtcp2_conn_shutdown_stream_write` sequentially with the following\n differences.  If |stream_id| refers to a local unidirectional\n stream, this function only shutdowns write side of the stream.  If\n |stream_id| refers to a remote unidirectional stream, this function\n only shutdowns read side of the stream.\n\n |flags| is currently unused, and should be set to 0.\n\n This function returns 0 if a stream denoted by |stream_id| is not\n found.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory"]
    pub fn ngtcp2_conn_shutdown_stream(
        conn: *mut ngtcp2_conn,
        flags: u32,
        stream_id: i64,
        app_error_code: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_shutdown_stream_write` closes write-side of a stream\n denoted by |stream_id| abruptly.  |app_error_code| is one of\n application error codes, and indicates the reason of shutdown.  If\n this function succeeds, no further application data is sent to the\n remote endpoint.  It discards all data which has not been\n acknowledged yet.\n\n |flags| is currently unused, and should be set to 0.\n\n This function returns 0 if a stream denoted by |stream_id| is not\n found.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     |stream_id| refers to a remote unidirectional stream."]
    pub fn ngtcp2_conn_shutdown_stream_write(
        conn: *mut ngtcp2_conn,
        flags: u32,
        stream_id: i64,
        app_error_code: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_shutdown_stream_read` closes read-side of a stream\n denoted by |stream_id| abruptly.  |app_error_code| is one of\n application error codes, and indicates the reason of shutdown.  If\n this function succeeds, no further application data is forwarded to\n an application layer.\n\n |flags| is currently unused, and should be set to 0.\n\n This function returns 0 if a stream denoted by |stream_id| is not\n found.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     |stream_id| refers to a local unidirectional stream."]
    pub fn ngtcp2_conn_shutdown_stream_read(
        conn: *mut ngtcp2_conn,
        flags: u32,
        stream_id: i64,
        app_error_code: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_write_stream` is just like\n `ngtcp2_conn_writev_stream`.  The only difference is that it\n conveniently accepts a single buffer."]
    pub fn ngtcp2_conn_write_stream_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        pdatalen: *mut ngtcp2_ssize,
        flags: u32,
        stream_id: i64,
        data: *const u8,
        datalen: usize,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_writev_stream` writes a packet containing stream data\n of a stream denoted by |stream_id|.  The buffer of the packet is\n pointed by |dest| of length |destlen|.  This function performs QUIC\n handshake as well.\n\n |destlen| should be at least\n :member:`ngtcp2_settings.max_tx_udp_payload_size`.  It must be at\n least :macro:`NGTCP2_MAX_UDP_PAYLOAD_SIZE`.\n\n Specifying -1 to |stream_id| means no new stream data to send.\n\n If |path| is not ``NULL``, this function stores the network path\n with which the packet should be sent.  Each addr field\n (:member:`ngtcp2_path.local` and :member:`ngtcp2_path.remote`) must\n point to the buffer which should be at least\n sizeof(:type:`sockaddr_union`) bytes long.  The assignment might\n not be done if nothing is written to |dest|.\n\n If |pi| is not ``NULL``, this function stores packet metadata in it\n if it succeeds.  The metadata includes ECN markings.  When calling\n this function again after it returns\n :macro:`NGTCP2_ERR_WRITE_MORE`, caller must pass the same |pi| to\n this function.\n\n Stream data is specified as vector of data |datav|.  |datavcnt|\n specifies the number of :type:`ngtcp2_vec` that |datav| includes.\n\n If all given data is encoded as STREAM frame in |dest|, and if\n |flags| & :macro:`NGTCP2_WRITE_STREAM_FLAG_FIN` is nonzero, fin\n flag is set to outgoing STREAM frame.  Otherwise, fin flag in\n STREAM frame is not set.\n\n This packet may contain frames other than STREAM frame.  The packet\n might not contain STREAM frame if other frames occupy the packet.\n In that case, |*pdatalen| would be -1 if |pdatalen| is not\n ``NULL``.\n\n Empty data is treated specially, and it is only accepted if no\n data, including the empty data, is submitted to a stream or\n :macro:`NGTCP2_WRITE_STREAM_FLAG_FIN` is set in |flags|.  If 0\n length STREAM frame is successfully serialized, |*pdatalen| would\n be 0.\n\n The number of data encoded in STREAM frame is stored in |*pdatalen|\n if it is not ``NULL``.  The caller must keep the portion of data\n covered by |*pdatalen| bytes in tact until\n :member:`ngtcp2_callbacks.acked_stream_data_offset` indicates that\n they are acknowledged by a remote endpoint or the stream is closed.\n\n If the given stream data is small (e.g., few bytes), the packet\n might be severely under filled.  Too many small packet might\n increase overall packet processing costs.  Unless there are\n retransmissions, by default, application can only send 1 STREAM\n frame in one QUIC packet.  In order to include more than 1 STREAM\n frame in one QUIC packet, specify\n :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE` in |flags|.  This is\n analogous to ``MSG_MORE`` flag in :manpage:`send(2)`.  If the\n :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE` is used, there are 4\n outcomes:\n\n - The function returns the written length of packet just like\n   without :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE`.  This is because\n   packet is nearly full, and the library decided to make a complete\n   packet.  |*pdatalen| might be -1 or >= 0.  It may return 0 which\n   indicates that no packet transmission is possible at the moment\n   for some reason.\n\n - The function returns :macro:`NGTCP2_ERR_WRITE_MORE`.  In this\n   case, |*pdatalen| >= 0 is asserted.  It indicates that\n   application can still call this function with different stream\n   data (or `ngtcp2_conn_writev_datagram` if it has data to send in\n   unreliable datagram) to pack them into the same packet.\n   Application has to specify the same |conn|, |path|, |pi|, |dest|,\n   |destlen|, and |ts| parameters, otherwise the behaviour is\n   undefined.  The application can change |flags|.\n\n - The function returns one of the following negative error codes:\n   :macro:`NGTCP2_ERR_STREAM_DATA_BLOCKED`,\n   :macro:`NGTCP2_ERR_STREAM_NOT_FOUND`, or\n   :macro:`NGTCP2_ERR_STREAM_SHUT_WR`.  In this case, |*pdatalen| ==\n   -1 is asserted.  Application can still write the stream data of\n   the other streams by calling this function (or\n   `ngtcp2_conn_writev_datagram` if it has data to send in\n   unreliable datagram) to pack them into the same packet.\n   Application has to specify the same |conn|, |path|, |pi|, |dest|,\n   |destlen|, and |ts| parameters, otherwise the behaviour is\n   undefined.  The application can change |flags|.\n\n - The other negative error codes might be returned just like\n   without :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE`.  These errors\n   should be treated as a connection error.\n\n When application uses :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE` at\n least once, it must not call other ngtcp2 API functions\n (application can still call `ngtcp2_conn_write_connection_close` to\n handle error from this function.  It can also call\n `ngtcp2_conn_shutdown_stream_read`,\n `ngtcp2_conn_shutdown_stream_write`, and\n `ngtcp2_conn_shutdown_stream`), just keep calling this function (or\n `ngtcp2_conn_writev_datagram`) until it returns 0, a positive\n number (which indicates a complete packet is ready), or the error\n codes other than :macro:`NGTCP2_ERR_WRITE_MORE`,\n :macro:`NGTCP2_ERR_STREAM_DATA_BLOCKED`,\n :macro:`NGTCP2_ERR_STREAM_NOT_FOUND`, and\n :macro:`NGTCP2_ERR_STREAM_SHUT_WR`.  If there is no stream data to\n include, call this function with |stream_id| as -1 to stop\n coalescing and write a packet.\n\n If :macro:`NGTCP2_WRITE_STREAM_FLAG_PADDING` is set in |flags| when\n finalizing a non-empty 0 RTT or 1 RTT ack-eliciting packet, the\n packet is padded to the minimum length of a sending path MTU or a\n given packet buffer.\n\n This function returns 0 if it cannot write any frame because buffer\n is too small, or packet is congestion limited.  Application should\n keep reading and wait for congestion window to grow.\n\n This function must not be called from inside the callback\n functions.\n\n `ngtcp2_conn_update_pkt_tx_time` must be called after this\n function.  Application may call this function multiple times before\n calling `ngtcp2_conn_update_pkt_tx_time`.\n\n This function returns the number of bytes written in |dest| if it\n succeeds, or one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_STREAM_NOT_FOUND`\n     Stream does not exist\n :macro:`NGTCP2_ERR_STREAM_SHUT_WR`\n     Stream is half closed (local); or stream is being reset.\n :macro:`NGTCP2_ERR_PKT_NUM_EXHAUSTED`\n     Packet number is exhausted, and cannot send any more packet.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     User callback failed\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     The total length of stream data is too large.\n :macro:`NGTCP2_ERR_STREAM_DATA_BLOCKED`\n     Stream is blocked because of flow control.\n :macro:`NGTCP2_ERR_WRITE_MORE`\n     (Only when :macro:`NGTCP2_WRITE_STREAM_FLAG_MORE` is specified)\n     Application can call this function to pack more stream data\n     into the same packet.  See above to know how it works.\n\n If any other negative error is returned, call\n `ngtcp2_conn_write_connection_close` to get terminal packet, and\n sending it makes QUIC connection enter the closing state."]
    pub fn ngtcp2_conn_writev_stream_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        pdatalen: *mut ngtcp2_ssize,
        flags: u32,
        stream_id: i64,
        datav: *const ngtcp2_vec,
        datavcnt: usize,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_write_datagram` is just like\n `ngtcp2_conn_writev_datagram`.  The only difference is that it\n conveniently accepts a single buffer."]
    pub fn ngtcp2_conn_write_datagram_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        paccepted: *mut ::std::os::raw::c_int,
        flags: u32,
        dgram_id: u64,
        data: *const u8,
        datalen: usize,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_writev_datagram` writes a packet containing unreliable\n data in DATAGRAM frame.  The buffer of the packet is pointed by\n |dest| of length |destlen|.  This function performs QUIC handshake\n as well.\n\n |destlen| should be at least\n :member:`ngtcp2_settings.max_tx_udp_payload_size`.  It must be at\n least :macro:`NGTCP2_MAX_UDP_PAYLOAD_SIZE`.\n\n For |path| and |pi| parameters, refer to\n `ngtcp2_conn_writev_stream`.\n\n Stream data is specified as vector of data |datav|.  |datavcnt|\n specifies the number of :type:`ngtcp2_vec` that |datav| includes.\n\n If the given data is written to the buffer, nonzero value is\n assigned to |*paccepted| if it is not NULL.  The data in DATAGRAM\n frame cannot be fragmented; writing partial data is not possible.\n\n |dgram_id| is an opaque identifier which should uniquely identify\n the given DATAGRAM data.  It is passed to\n :member:`ngtcp2_callbacks.ack_datagram` callback when a packet that\n contains DATAGRAM frame is acknowledged.  It is also passed to\n :member:`ngtcp2_callbacks.lost_datagram` callback when a packet\n that contains DATAGRAM frame is declared lost.  If an application\n uses neither of those callbacks, it can sets 0 to this parameter.\n\n This function might write other frames other than DATAGRAM frame,\n just like `ngtcp2_conn_writev_stream`.\n\n If the function returns 0, it means that no more data cannot be\n sent because of congestion control limit; or, data does not fit\n into the provided buffer; or, a local endpoint, as a server, is\n unable to send data because of its amplification limit.  In this\n case, |*paccepted| is assigned zero if it is not NULL.\n\n If :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_MORE` is set in |flags|,\n there are 3 outcomes:\n\n - The function returns the written length of packet just like\n   without :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_MORE`.  This is\n   because packet is nearly full and the library decided to make a\n   complete packet.  |*paccepted| might be zero or nonzero.\n\n - The function returns :macro:`NGTCP2_ERR_WRITE_MORE`.  In this\n   case, |*paccepted| != 0 is asserted.  This indicates that\n   application can call this function with another unreliable data\n   (or `ngtcp2_conn_writev_stream` if it has stream data to send) to\n   pack them into the same packet.  Application has to specify the\n   same |conn|, |path|, |pi|, |dest|, |destlen|, and |ts|\n   parameters, otherwise the behaviour is undefined.  The\n   application can change |flags|.\n\n - The other error might be returned just like without\n   :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_MORE`.\n\n When application sees :macro:`NGTCP2_ERR_WRITE_MORE`, it must not\n call other ngtcp2 API functions (application can still call\n `ngtcp2_conn_write_connection_close` to handle error from this\n function.  It can also call `ngtcp2_conn_shutdown_stream_read`,\n `ngtcp2_conn_shutdown_stream_write`, and\n `ngtcp2_conn_shutdown_stream`).  Just keep calling this function\n (or `ngtcp2_conn_writev_stream`) until it returns a positive number\n (which indicates a complete packet is ready).\n\n If :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_PADDING` is set in |flags|\n when finalizing a non-empty 0 RTT or 1 RTT ack-eliciting packet,\n the packet is padded to the minimum length of a sending path MTU or\n a given packet buffer.\n\n This function returns the number of bytes written in |dest| if it\n succeeds, or one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_PKT_NUM_EXHAUSTED`\n     Packet number is exhausted, and cannot send any more packet.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     User callback failed\n :macro:`NGTCP2_ERR_WRITE_MORE`\n     (Only when :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_MORE` is\n     specified) Application can call this function to pack more data\n     into the same packet.  See above to know how it works.\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     A remote endpoint did not express the DATAGRAM frame support.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     The provisional DATAGRAM frame size exceeds the maximum\n     DATAGRAM frame size that a remote endpoint can receive.\n\n If any other negative error is returned, call\n `ngtcp2_conn_write_connection_close` to get terminal packet, and\n sending it makes QUIC connection enter the closing state."]
    pub fn ngtcp2_conn_writev_datagram_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        paccepted: *mut ::std::os::raw::c_int,
        flags: u32,
        dgram_id: u64,
        datav: *const ngtcp2_vec,
        datavcnt: usize,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_in_closing_period` returns nonzero if |conn| is in the\n closing period."]
    pub fn ngtcp2_conn_in_closing_period(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_in_draining_period` returns nonzero if |conn| is in\n the draining period."]
    pub fn ngtcp2_conn_in_draining_period(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_extend_max_stream_offset` extends the maximum stream\n data that a remote endpoint can send by |datalen|.  |stream_id|\n specifies the stream ID.  This function only extends stream-level\n flow control window.\n\n This function returns 0 if a stream denoted by |stream_id| is not\n found.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     |stream_id| refers to a local unidirectional stream."]
    pub fn ngtcp2_conn_extend_max_stream_offset(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        datalen: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_extend_max_offset` extends max data offset by\n |datalen|.  This function only extends connection-level flow\n control window."]
    pub fn ngtcp2_conn_extend_max_offset(conn: *mut ngtcp2_conn, datalen: u64);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_extend_max_streams_bidi` extends the number of maximum\n remote bidirectional streams that a remote endpoint can open by\n |n|.\n\n The library does not increase maximum stream limit automatically.\n The exception is when a stream is closed without\n :member:`ngtcp2_callbacks.stream_open` callback being called.  In\n this case, stream limit is increased automatically."]
    pub fn ngtcp2_conn_extend_max_streams_bidi(conn: *mut ngtcp2_conn, n: usize);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_extend_max_streams_uni` extends the number of maximum\n remote unidirectional streams that a remote endpoint can open by\n |n|.\n\n The library does not increase maximum stream limit automatically.\n The exception is when a stream is closed without\n :member:`ngtcp2_callbacks.stream_open` callback being called.  In\n this case, stream limit is increased automatically."]
    pub fn ngtcp2_conn_extend_max_streams_uni(conn: *mut ngtcp2_conn, n: usize);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_dcid` returns the non-NULL pointer to the current\n Destination Connection ID.  If no Destination Connection ID is\n present, the return value is not ``NULL``, and its :member:`datalen\n <ngtcp2_cid.datalen>` field is 0."]
    pub fn ngtcp2_conn_get_dcid(conn: *mut ngtcp2_conn) -> *const ngtcp2_cid;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_client_initial_dcid` returns the non-NULL pointer\n to the Destination Connection ID that client sent in its Initial\n packet.  If the Destination Connection ID is not present, the\n return value is not ``NULL``, and its :member:`datalen\n <ngtcp2_cid.datalen>` field is 0."]
    pub fn ngtcp2_conn_get_client_initial_dcid(conn: *mut ngtcp2_conn) -> *const ngtcp2_cid;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_scid` writes the all Source Connection IDs which a\n local endpoint has provided to a remote endpoint, and are not\n retired in |dest|.  If |dest| is NULL, this function does not write\n anything, and returns the number of Source Connection IDs that\n would otherwise be written to the provided buffer.  The buffer\n pointed by |dest| must have sizeof(:type:`ngtcp2_cid`) * n bytes\n available, where n is the return value of `ngtcp2_conn_get_scid`\n with |dest| == NULL."]
    pub fn ngtcp2_conn_get_scid(conn: *mut ngtcp2_conn, dest: *mut ngtcp2_cid) -> usize;
}
#[doc = " @struct\n\n :type:`ngtcp2_cid_token` is the convenient struct to store\n Connection ID, its associated path, and stateless reset token."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngtcp2_cid_token {
    #[doc = " :member:`seq` is the sequence number of this Connection ID."]
    pub seq: u64,
    #[doc = " :member:`cid` is Connection ID."]
    pub cid: ngtcp2_cid,
    #[doc = " :member:`ps` is the path which this Connection ID is associated\n with."]
    pub ps: ngtcp2_path_storage,
    #[doc = " :member:`token` is the stateless reset token for this Connection\n ID."]
    pub token: [u8; 16usize],
    #[doc = " :member:`token_present` is nonzero if token contains stateless\n reset token."]
    pub token_present: u8,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_active_dcid` writes the all active Destination\n Connection IDs and their tokens to |dest|.  Before handshake\n completes, this function returns 0.  If |dest| is NULL, this\n function does not write anything, and returns the number of\n Destination Connection IDs that would otherwise be written to the\n provided buffer.  The buffer pointed by |dest| must have\n sizeof(:type:`ngtcp2_cid_token`) * n bytes available, where n is\n the return value of `ngtcp2_conn_get_active_dcid` with |dest| ==\n NULL."]
    pub fn ngtcp2_conn_get_active_dcid(
        conn: *mut ngtcp2_conn,
        dest: *mut ngtcp2_cid_token,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_client_chosen_version` returns the client chosen\n version."]
    pub fn ngtcp2_conn_get_client_chosen_version(conn: *mut ngtcp2_conn) -> u32;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_negotiated_version` returns the negotiated\n version.\n\n Until the version is negotiated, this function returns 0."]
    pub fn ngtcp2_conn_get_negotiated_version(conn: *mut ngtcp2_conn) -> u32;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_tls_early_data_rejected` tells |conn| that early data\n was rejected by a server during TLS handshake, or client decided\n not to attempt early data for some reason.  |conn| discards the\n following connection states:\n\n - Any opened streams.\n - Stream identifier allocations.\n - Max data extended by `ngtcp2_conn_extend_max_offset`.\n - Max bidi streams extended by `ngtcp2_conn_extend_max_streams_bidi`.\n - Max uni streams extended by `ngtcp2_conn_extend_max_streams_uni`.\n\n Application which wishes to retransmit early data, it has to open\n streams, and send stream data again.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     User callback failed"]
    pub fn ngtcp2_conn_tls_early_data_rejected(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_tls_early_data_rejected` returns nonzero if\n `ngtcp2_conn_tls_early_data_rejected` has been called."]
    pub fn ngtcp2_conn_get_tls_early_data_rejected(conn: *mut ngtcp2_conn)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_conn_info` assigns connection statistics data to\n |*cinfo|."]
    pub fn ngtcp2_conn_get_conn_info_versioned(
        conn: *mut ngtcp2_conn,
        conn_info_version: ::std::os::raw::c_int,
        cinfo: *mut ngtcp2_conn_info,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_submit_crypto_data` submits crypto data |data| of\n length |datalen| to the library for transmission.\n |encryption_level| specifies the encryption level of data.\n\n The library makes a copy of the buffer pointed by |data| of length\n |datalen|.  Application can discard |data|."]
    pub fn ngtcp2_conn_submit_crypto_data(
        conn: *mut ngtcp2_conn,
        encryption_level: ngtcp2_encryption_level,
        data: *const u8,
        datalen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_submit_new_token` submits address validation token.\n It is sent in NEW_TOKEN frame.  Only server can call this function.\n |tokenlen| must not be 0.\n\n This function makes a copy of the buffer pointed by |token| of\n length |tokenlen|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory."]
    pub fn ngtcp2_conn_submit_new_token(
        conn: *mut ngtcp2_conn,
        token: *const u8,
        tokenlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_local_addr` sets local endpoint address |addr| to\n the current path of |conn|.  This function is provided for testing\n purpose only."]
    pub fn ngtcp2_conn_set_local_addr(conn: *mut ngtcp2_conn, addr: *const ngtcp2_addr);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_path_user_data` sets the |path_user_data| to the\n current path (see :member:`ngtcp2_path.user_data`)."]
    pub fn ngtcp2_conn_set_path_user_data(
        conn: *mut ngtcp2_conn,
        path_user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_path` returns the current path."]
    pub fn ngtcp2_conn_get_path(conn: *mut ngtcp2_conn) -> *const ngtcp2_path;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_max_tx_udp_payload_size` returns the maximum UDP\n payload size that this local endpoint would send.  This is the\n value of :member:`ngtcp2_settings.max_tx_udp_payload_size` that is\n passed to `ngtcp2_conn_client_new` or `ngtcp2_conn_server_new`."]
    pub fn ngtcp2_conn_get_max_tx_udp_payload_size(conn: *mut ngtcp2_conn) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_path_max_tx_udp_payload_size` returns the maximum\n UDP payload size for the current path.  If\n :member:`ngtcp2_settings.no_tx_udp_payload_size_shaping` is set to\n nonzero, this function is equivalent to\n `ngtcp2_conn_get_max_tx_udp_payload_size`.  Otherwise, it returns\n the maximum UDP payload size that is probed for the current path."]
    pub fn ngtcp2_conn_get_path_max_tx_udp_payload_size(conn: *mut ngtcp2_conn) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_initiate_immediate_migration` starts connection\n migration to the given |path|.  Only client can initiate migration.\n This function does immediate migration; while the path validation\n is nonetheless performed, this function does not wait for it to\n succeed.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     Migration is disabled; or handshake is not yet confirmed; or\n     client is migrating to server's preferred address.\n :macro:`NGTCP2_ERR_CONN_ID_BLOCKED`\n     No unused connection ID is available.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     :member:`local <ngtcp2_path.local>` field of |path| equals the\n     current local address.\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory"]
    pub fn ngtcp2_conn_initiate_immediate_migration(
        conn: *mut ngtcp2_conn,
        path: *const ngtcp2_path,
        ts: ngtcp2_tstamp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_initiate_migration` starts connection migration to the\n given |path|.  Only client can initiate migration.  Unlike\n `ngtcp2_conn_initiate_immediate_migration`, this function starts a\n path validation with a new path, and migrate to the new path after\n successful path validation.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     Migration is disabled; or handshake is not yet confirmed; or\n     client is migrating to server's preferred address.\n :macro:`NGTCP2_ERR_CONN_ID_BLOCKED`\n     No unused connection ID is available.\n :macro:`NGTCP2_ERR_INVALID_ARGUMENT`\n     :member:`local <ngtcp2_path.local>` field of |path| equals the\n     current local address.\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory"]
    pub fn ngtcp2_conn_initiate_migration(
        conn: *mut ngtcp2_conn,
        path: *const ngtcp2_path,
        ts: ngtcp2_tstamp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_max_data_left` returns the number of bytes that\n this local endpoint can send in this connection without violating\n connection-level flow control."]
    pub fn ngtcp2_conn_get_max_data_left(conn: *mut ngtcp2_conn) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_max_stream_data_left` returns the number of bytes\n that this local endpoint can send to a stream identified by\n |stream_id| without violating stream-level flow control.  If no\n such stream is found, this function returns 0."]
    pub fn ngtcp2_conn_get_max_stream_data_left(conn: *mut ngtcp2_conn, stream_id: i64) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_streams_bidi_left` returns the number of\n bidirectional streams which the local endpoint can open without\n violating stream concurrency limit."]
    pub fn ngtcp2_conn_get_streams_bidi_left(conn: *mut ngtcp2_conn) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_streams_uni_left` returns the number of\n unidirectional streams which the local endpoint can open without\n violating stream concurrency limit."]
    pub fn ngtcp2_conn_get_streams_uni_left(conn: *mut ngtcp2_conn) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_cwnd_left` returns the cwnd minus the number of\n bytes in flight on the current path.  If the former is smaller than\n the latter, this function returns 0."]
    pub fn ngtcp2_conn_get_cwnd_left(conn: *mut ngtcp2_conn) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_initial_crypto_ctx` sets |ctx| for Initial packet\n encryption.  The passed data will be passed to\n :type:`ngtcp2_encrypt`, :type:`ngtcp2_decrypt` and\n :type:`ngtcp2_hp_mask` callbacks."]
    pub fn ngtcp2_conn_set_initial_crypto_ctx(
        conn: *mut ngtcp2_conn,
        ctx: *const ngtcp2_crypto_ctx,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_initial_crypto_ctx` returns\n :type:`ngtcp2_crypto_ctx` object for Initial packet encryption."]
    pub fn ngtcp2_conn_get_initial_crypto_ctx(conn: *mut ngtcp2_conn) -> *const ngtcp2_crypto_ctx;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_crypto_ctx` sets |ctx| for Handshake/1-RTT packet\n encryption.  The passed data will be passed to\n :type:`ngtcp2_encrypt`, :type:`ngtcp2_decrypt` and\n :type:`ngtcp2_hp_mask` callbacks."]
    pub fn ngtcp2_conn_set_crypto_ctx(conn: *mut ngtcp2_conn, ctx: *const ngtcp2_crypto_ctx);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_crypto_ctx` returns :type:`ngtcp2_crypto_ctx`\n object for Handshake/1-RTT packet encryption."]
    pub fn ngtcp2_conn_get_crypto_ctx(conn: *mut ngtcp2_conn) -> *const ngtcp2_crypto_ctx;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_0rtt_crypto_ctx` sets |ctx| for 0-RTT packet\n encryption.  The passed data will be passed to\n :type:`ngtcp2_encrypt`, :type:`ngtcp2_decrypt` and\n :type:`ngtcp2_hp_mask` callbacks."]
    pub fn ngtcp2_conn_set_0rtt_crypto_ctx(conn: *mut ngtcp2_conn, ctx: *const ngtcp2_crypto_ctx);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_0rtt_crypto_ctx` returns :type:`ngtcp2_crypto_ctx`\n object for 0-RTT packet encryption."]
    pub fn ngtcp2_conn_get_0rtt_crypto_ctx(conn: *mut ngtcp2_conn) -> *const ngtcp2_crypto_ctx;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_tls_native_handle` returns TLS native handle set\n by `ngtcp2_conn_set_tls_native_handle`."]
    pub fn ngtcp2_conn_get_tls_native_handle(conn: *mut ngtcp2_conn)
        -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_tls_native_handle` sets TLS native handle\n |tls_native_handle| to |conn|.  Internally, it is used as an opaque\n pointer."]
    pub fn ngtcp2_conn_set_tls_native_handle(
        conn: *mut ngtcp2_conn,
        tls_native_handle: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_retry_aead` sets |aead| and |aead_ctx| for Retry\n integrity tag verification.  |aead| must be AEAD_AES_128_GCM.\n |aead_ctx| must be initialized with :macro:`NGTCP2_RETRY_KEY` as\n encryption key.  This function must be called if |conn| is\n initialized as client.  Server does not verify the tag, and has no\n need to call this function.\n\n |conn| takes ownership of |aead_ctx|.\n :member:`ngtcp2_callbacks.delete_crypto_aead_ctx` will be called to\n delete this object when it is no longer used."]
    pub fn ngtcp2_conn_set_retry_aead(
        conn: *mut ngtcp2_conn,
        aead: *const ngtcp2_crypto_aead,
        aead_ctx: *const ngtcp2_crypto_aead_ctx,
    );
}
#[doc = " :enum:`NGTCP2_CCERR_TYPE_TRANSPORT` indicates the QUIC transport\n error, and the error code is QUIC transport error code."]
pub const NGTCP2_CCERR_TYPE_TRANSPORT: ngtcp2_ccerr_type = 0;
#[doc = " :enum:`NGTCP2_CCERR_TYPE_APPLICATION` indicates an application\n error, and the error code is application error code."]
pub const NGTCP2_CCERR_TYPE_APPLICATION: ngtcp2_ccerr_type = 1;
#[doc = " :enum:`NGTCP2_CCERR_TYPE_VERSION_NEGOTIATION` is a special case\n of QUIC transport error, and it indicates that client receives\n Version Negotiation packet."]
pub const NGTCP2_CCERR_TYPE_VERSION_NEGOTIATION: ngtcp2_ccerr_type = 2;
#[doc = " :enum:`NGTCP2_CCERR_TYPE_IDLE_CLOSE` is a special case of QUIC\n transport error, and it indicates that connection is closed\n because of idle timeout."]
pub const NGTCP2_CCERR_TYPE_IDLE_CLOSE: ngtcp2_ccerr_type = 3;
#[doc = " :enum:`NGTCP2_CCERR_TYPE_DROP_CONN` is a special case of QUIC\n transport error, and it indicates that connection should be\n dropped without sending a CONNECTION_CLOSE frame."]
pub const NGTCP2_CCERR_TYPE_DROP_CONN: ngtcp2_ccerr_type = 4;
#[doc = " :enum:`NGTCP2_CCERR_TYPE_RETRY` is a special case of QUIC\n transport error, and it indicates that RETRY packet should be\n sent to a client."]
pub const NGTCP2_CCERR_TYPE_RETRY: ngtcp2_ccerr_type = 5;
#[doc = " @enum\n\n :type:`ngtcp2_ccerr_type` defines connection error type."]
pub type ngtcp2_ccerr_type = ::std::os::raw::c_uint;
#[doc = " @struct\n\n :type:`ngtcp2_ccerr` contains connection error code, its type, a\n frame type that caused this error, and the optional reason phrase."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_ccerr {
    #[doc = " :member:`type` is the type of this error."]
    pub type_: ngtcp2_ccerr_type,
    #[doc = " :member:`error_code` is the error code for connection closure.\n Its interpretation depends on :member:`type`."]
    pub error_code: u64,
    #[doc = " :member:`frame_type` is the type of QUIC frame which triggers\n this connection error.  This field is set to 0 if the frame type\n is unknown."]
    pub frame_type: u64,
    #[doc = " :member:`reason` points to the buffer which contains a reason\n phrase.  It may be NULL if there is no reason phrase.  If it is\n received from a remote endpoint, it is truncated to at most 1024\n bytes."]
    pub reason: *const u8,
    #[doc = " :member:`reasonlen` is the length of data pointed by\n :member:`reason`."]
    pub reasonlen: usize,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_ccerr_default` initializes |ccerr| with the default values.\n It sets the following fields:\n\n - :member:`type <ngtcp2_ccerr.type>` =\n   :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_TRANSPORT`\n - :member:`error_code <ngtcp2_ccerr.error_code>` =\n   :macro:`NGTCP2_NO_ERROR`.\n - :member:`frame_type <ngtcp2_ccerr.frame_type>` = 0\n - :member:`reason <ngtcp2_ccerr.reason>` = NULL\n - :member:`reasonlen <ngtcp2_ccerr.reasonlen>` = 0"]
    pub fn ngtcp2_ccerr_default(ccerr: *mut ngtcp2_ccerr);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_ccerr_set_transport_error` sets :member:`ccerr->type\n <ngtcp2_ccerr.type>` to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_TRANSPORT`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to\n |error_code|.  |reason| is the reason phrase of length |reasonlen|.\n This function does not make a copy of the reason phrase."]
    pub fn ngtcp2_ccerr_set_transport_error(
        ccerr: *mut ngtcp2_ccerr,
        error_code: u64,
        reason: *const u8,
        reasonlen: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_ccerr_set_liberr` sets type and error_code based on\n |liberr|.\n\n |reason| is the reason phrase of length |reasonlen|.  This function\n does not make a copy of the reason phrase.\n\n If |liberr| is :macro:`NGTCP2_ERR_RECV_VERSION_NEGOTIATION`,\n :member:`ccerr->type <ngtcp2_ccerr.type>` is set to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_VERSION_NEGOTIATION`,\n and :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to\n :macro:`NGTCP2_NO_ERROR`.\n\n If |liberr| is :macro:`NGTCP2_ERR_IDLE_CLOSE`, :member:`ccerr->type\n <ngtcp2_ccerr.type>` is set to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_IDLE_CLOSE`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to\n :macro:`NGTCP2_NO_ERROR`.\n\n If |liberr| is :macro:`NGTCP2_ERR_DROP_CONN`, :member:`ccerr->type\n <ngtcp2_ccerr.type>` is set to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_DROP_CONN`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to\n :macro:`NGTCP2_NO_ERROR`.\n\n If |liberr| is :macro:`NGTCP2_ERR_RETRY`, :member:`ccerr->type\n <ngtcp2_ccerr.type>` is set to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_RETRY`, and\n :member:`ccerr->error_type <ngtcp2_ccerr.error_code>` to\n :macro:`NGTCP2_NO_ERROR`.\n\n Otherwise, :member:`ccerr->type <ngtcp2_ccerr.type>` is set to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_TRANSPORT`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` is set to an\n error code inferred by |liberr| (see\n `ngtcp2_err_infer_quic_transport_error_code`)."]
    pub fn ngtcp2_ccerr_set_liberr(
        ccerr: *mut ngtcp2_ccerr,
        liberr: ::std::os::raw::c_int,
        reason: *const u8,
        reasonlen: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_ccerr_set_tls_alert` sets :member:`ccerr->type\n <ngtcp2_ccerr.type>` to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_TRANSPORT`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to bitwise-OR\n of :macro:`NGTCP2_CRYPTO_ERROR` and |tls_alert|.  |reason| is the\n reason phrase of length |reasonlen|.  This function does not make a\n copy of the reason phrase."]
    pub fn ngtcp2_ccerr_set_tls_alert(
        ccerr: *mut ngtcp2_ccerr,
        tls_alert: u8,
        reason: *const u8,
        reasonlen: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_ccerr_set_application_error` sets :member:`ccerr->type\n <ngtcp2_ccerr.type>` to\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_APPLICATION`, and\n :member:`ccerr->error_code <ngtcp2_ccerr.error_code>` to\n |error_code|.  |reason| is the reason phrase of length |reasonlen|.\n This function does not make a copy of the reason phrase."]
    pub fn ngtcp2_ccerr_set_application_error(
        ccerr: *mut ngtcp2_ccerr,
        error_code: u64,
        reason: *const u8,
        reasonlen: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_write_connection_close` writes a packet which contains\n CONNECTION_CLOSE frame(s) (type 0x1c or 0x1d) in the buffer pointed\n by |dest| whose capacity is |destlen|.\n\n For client, |destlen| should be at least\n :macro:`NGTCP2_MAX_UDP_PAYLOAD_SIZE`.\n\n If |path| is not ``NULL``, this function stores the network path\n with which the packet should be sent.  Each addr field must point\n to the buffer which should be at least\n sizeof(:type:`ngtcp2_sockaddr_union`) bytes long.  The assignment\n might not be done if nothing is written to |dest|.\n\n If |pi| is not ``NULL``, this function stores packet metadata in it\n if it succeeds.  The metadata includes ECN markings.\n\n If :member:`ccerr->type <ngtcp2_ccerr.type>` ==\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_TRANSPORT`, this\n function sends CONNECTION_CLOSE (type 0x1c) frame.  If\n :member:`ccerr->type <ngtcp2_ccerr.type>` ==\n :enum:`ngtcp2_ccerr_type.NGTCP2_CCERR_TYPE_APPLICATION`, it sends\n CONNECTION_CLOSE (type 0x1d) frame.  Otherwise, it does not produce\n any data, and returns 0.\n\n |destlen| could be shorten by some factors (e.g., server side\n amplification limit).  This function returns\n :macro:`NGTCP2_ERR_NOBUF` if the resulting buffer is too small even\n if the given buffer has enough space.\n\n This function must not be called from inside the callback\n functions.\n\n At the moment, successful call to this function makes connection\n close.  We may change this behaviour in the future to allow\n graceful shutdown.\n\n This function returns the number of bytes written in |dest| if it\n succeeds, or one of the following negative error codes:\n\n :macro:`NGTCP2_ERR_NOMEM`\n     Out of memory\n :macro:`NGTCP2_ERR_NOBUF`\n     Buffer is too small\n :macro:`NGTCP2_ERR_INVALID_STATE`\n     The current state does not allow sending CONNECTION_CLOSE\n     frame.\n :macro:`NGTCP2_ERR_PKT_NUM_EXHAUSTED`\n     Packet number is exhausted, and cannot send any more packet.\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`\n     User callback failed"]
    pub fn ngtcp2_conn_write_connection_close_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        ccerr: *const ngtcp2_ccerr,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_ccerr` returns the received connection close\n error.  If no connection error is received, it returns\n :type:`ngtcp2_ccerr` that is initialized by `ngtcp2_ccerr_default`."]
    pub fn ngtcp2_conn_get_ccerr(conn: *mut ngtcp2_conn) -> *const ngtcp2_ccerr;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_is_local_stream` returns nonzero if |stream_id|\n denotes a locally initiated stream."]
    pub fn ngtcp2_conn_is_local_stream(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_is_server` returns nonzero if |conn| is initialized as\n server."]
    pub fn ngtcp2_conn_is_server(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_after_retry` returns nonzero if |conn| as a client has\n received Retry packet from server, and successfully validated it."]
    pub fn ngtcp2_conn_after_retry(conn: *mut ngtcp2_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_set_stream_user_data` sets |stream_user_data| to the\n stream identified by |stream_id|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGTCP2_ERR_STREAM_NOT_FOUND`\n     Stream does not exist"]
    pub fn ngtcp2_conn_set_stream_user_data(
        conn: *mut ngtcp2_conn,
        stream_id: i64,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_update_pkt_tx_time` sets the time instant of the next\n packet transmission to pace packets.  This function must be called\n after (multiple invocation of) `ngtcp2_conn_writev_stream`.  If\n packet aggregation (e.g., packet batching, GSO) is used, call this\n function after all aggregated datagrams are sent, which indicates\n multiple invocation of `ngtcp2_conn_writev_stream`."]
    pub fn ngtcp2_conn_update_pkt_tx_time(conn: *mut ngtcp2_conn, ts: ngtcp2_tstamp);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_send_quantum` returns the maximum number of bytes\n that can be sent in one go without packet spacing."]
    pub fn ngtcp2_conn_get_send_quantum(conn: *mut ngtcp2_conn) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_get_stream_loss_count` returns the number of packets\n that contain STREAM frame for a stream identified by |stream_id|\n and are declared to be lost.  The number may include the spurious\n losses.  If no stream identified by |stream_id| is found, this\n function returns 0."]
    pub fn ngtcp2_conn_get_stream_loss_count(conn: *mut ngtcp2_conn, stream_id: i64) -> usize;
}
#[doc = " @functypedef\n\n :type:`ngtcp2_write_pkt` is a callback function to write a single\n packet in the buffer pointed by |dest| of length |destlen|.  The\n implementation should use `ngtcp2_conn_write_pkt`,\n `ngtcp2_conn_writev_stream`, `ngtcp2_conn_writev_datagram`, or\n their variants to write the packet.  |path| and |pi| should be\n directly passed to those functions.  If the callback succeeds, it\n should return the number of bytes written to the buffer.  In\n general, this callback function should return the value that the\n above mentioned functions returned except for the following error\n codes:\n\n - :macro:`NGTCP2_ERR_STREAM_DATA_BLOCKED`\n - :macro:`NGTCP2_ERR_STREAM_SHUT_WR`\n - :macro:`NGTCP2_ERR_STREAM_NOT_FOUND`\n\n Those error codes should be handled by an application.  If any\n error occurred outside those functions, return\n :macro:`NGTCP2_ERR_CALLBACK_FAILURE`.  If no packet is produced,\n return 0.\n\n Because GSO requires that the aggregated packets have the same\n length, :macro:`NGTCP2_WRITE_STREAM_FLAG_PADDING` (or\n :macro:`NGTCP2_WRITE_DATAGRAM_FLAG_PADDING` if\n `ngtcp2_conn_writev_datagram` is used) is recommended.\n\n This callback function has been available since v1.15.0."]
pub type ngtcp2_write_pkt = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pi: *mut ngtcp2_pkt_info,
        dest: *mut u8,
        destlen: usize,
        ts: ngtcp2_tstamp,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ngtcp2_ssize,
>;
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_conn_write_aggregate_pkt` is a helper function to write\n multiple packets in the provided buffer, which is suitable to be\n sent at once in GSO.  This function returns the number of bytes\n written to the buffer pointed by |buf| of length |buflen|.\n |buflen| must be at least\n `ngtcp2_conn_get_path_max_tx_udp_payload_size(conn)\n <ngtcp2_conn_get_path_max_tx_udp_payload_size>` bytes long.  It is\n recommended to pass the buffer at least\n `ngtcp2_conn_get_max_tx_udp_payload_size(conn)\n <ngtcp2_conn_get_max_tx_udp_payload_size>` bytes in order to send a\n PMTUD packet.  This function only writes multiple packets if the\n first packet is `ngtcp2_conn_get_path_max_tx_udp_payload_size(conn)\n <ngtcp2_conn_get_path_max_tx_udp_payload_size>` bytes long.  The\n application can adjust the length of the buffer to limit the number\n of packets to aggregate.  If this function returns positive\n integer, all packets share the same :type:`ngtcp2_path` and\n :type:`ngtcp2_pkt_info` values, and they are assigned to the\n objects pointed by |path| and |pi| respectively.  The length of all\n packets other than the last packet is assigned to |*pgsolen|.  The\n length of last packet is equal to or less than |*pgsolen|.\n |write_pkt| must write a single packet.  After all packets are\n written, this function calls `ngtcp2_conn_update_pkt_tx_time`.\n\n This function returns the number of bytes written to the buffer, or\n a negative error code returned by |write_pkt|.\n\n This function has been available since v1.15.0."]
    pub fn ngtcp2_conn_write_aggregate_pkt_versioned(
        conn: *mut ngtcp2_conn,
        path: *mut ngtcp2_path,
        pkt_info_version: ::std::os::raw::c_int,
        pi: *mut ngtcp2_pkt_info,
        buf: *mut u8,
        buflen: usize,
        pgsolen: *mut usize,
        write_pkt: ngtcp2_write_pkt,
        ts: ngtcp2_tstamp,
    ) -> ngtcp2_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_strerror` returns the text representation of |liberr|.\n |liberr| must be one of ngtcp2 library error codes (which is\n defined as :macro:`NGTCP2_ERR_* <NGTCP2_ERR_INVALID_ARGUMENT>`\n macros)."]
    pub fn ngtcp2_strerror(liberr: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_err_is_fatal` returns nonzero if |liberr| is a fatal error.\n |liberr| must be one of ngtcp2 library error codes (which is\n defined as :macro:`NGTCP2_ERR_* <NGTCP2_ERR_INVALID_ARGUMENT>`\n macros)."]
    pub fn ngtcp2_err_is_fatal(liberr: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_err_infer_quic_transport_error_code` returns a QUIC\n transport error code which corresponds to |liberr|.  |liberr| must\n be one of ngtcp2 library error codes (which is defined as\n :macro:`NGTCP2_ERR_* <NGTCP2_ERR_INVALID_ARGUMENT>` macros)."]
    pub fn ngtcp2_err_infer_quic_transport_error_code(liberr: ::std::os::raw::c_int) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_addr_init` initializes |dest| with the given arguments and\n returns |dest|."]
    pub fn ngtcp2_addr_init(
        dest: *mut ngtcp2_addr,
        addr: *const ngtcp2_sockaddr,
        addrlen: ngtcp2_socklen,
    ) -> *mut ngtcp2_addr;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_addr_copy_byte` copies |addr| of length |addrlen| into the\n buffer pointed by :member:`dest->addr <ngtcp2_addr.addr>`.\n :member:`dest->addrlen <ngtcp2_addr.addrlen>` is updated to have\n |addrlen|.  This function assumes that :member:`dest->addr\n <ngtcp2_addr.addr>` points to a buffer which has a sufficient\n capacity to store the copy."]
    pub fn ngtcp2_addr_copy_byte(
        dest: *mut ngtcp2_addr,
        addr: *const ngtcp2_sockaddr,
        addrlen: ngtcp2_socklen,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_path_storage_init` initializes |ps| with the given\n arguments.  This function copies |local_addr| and |remote_addr|."]
    pub fn ngtcp2_path_storage_init(
        ps: *mut ngtcp2_path_storage,
        local_addr: *const ngtcp2_sockaddr,
        local_addrlen: ngtcp2_socklen,
        remote_addr: *const ngtcp2_sockaddr,
        remote_addrlen: ngtcp2_socklen,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_path_storage_zero` initializes |ps| with the zero length\n addresses."]
    pub fn ngtcp2_path_storage_zero(ps: *mut ngtcp2_path_storage);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_settings_default` initializes |settings| with the default\n values.  First this function fills |settings| with 0, and set the\n default value to the following fields:\n\n * :type:`cc_algo <ngtcp2_settings.cc_algo>` =\n   :enum:`ngtcp2_cc_algo.NGTCP2_CC_ALGO_CUBIC`\n * :type:`initial_rtt <ngtcp2_settings.initial_rtt>` =\n   :macro:`NGTCP2_DEFAULT_INITIAL_RTT`\n * :type:`ack_thresh <ngtcp2_settings.ack_thresh>` = 2\n * :type:`max_tx_udp_payload_size\n   <ngtcp2_settings.max_tx_udp_payload_size>` = 1452\n * :type:`handshake_timeout <ngtcp2_settings.handshake_timeout>` =\n   ``UINT64_MAX``"]
    pub fn ngtcp2_settings_default_versioned(
        settings_version: ::std::os::raw::c_int,
        settings: *mut ngtcp2_settings,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_transport_params_default` initializes |params| with the\n default values.  First this function fills |params| with 0, and set\n the default value to the following fields:\n\n * :type:`max_udp_payload_size\n   <ngtcp2_transport_params.max_udp_payload_size>` =\n   :macro:`NGTCP2_DEFAULT_MAX_RECV_UDP_PAYLOAD_SIZE`\n * :type:`ack_delay_exponent\n   <ngtcp2_transport_params.ack_delay_exponent>` =\n   :macro:`NGTCP2_DEFAULT_ACK_DELAY_EXPONENT`\n * :type:`max_ack_delay <ngtcp2_transport_params.max_ack_delay>` =\n   :macro:`NGTCP2_DEFAULT_MAX_ACK_DELAY`\n * :type:`active_connection_id_limit\n   <ngtcp2_transport_params.active_connection_id_limit>` =\n   :macro:`NGTCP2_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT`"]
    pub fn ngtcp2_transport_params_default_versioned(
        transport_params_version: ::std::os::raw::c_int,
        params: *mut ngtcp2_transport_params,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_mem_default` returns the default, system standard memory\n allocator."]
    pub fn ngtcp2_mem_default() -> *const ngtcp2_mem;
}
#[doc = " @struct\n\n :type:`ngtcp2_info` is what `ngtcp2_version` returns.  It holds\n information about the particular ngtcp2 version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngtcp2_info {
    #[doc = " :member:`age` is the age of this struct.  This instance of ngtcp2\n sets it to :macro:`NGTCP2_VERSION_AGE` but a future version may\n bump it and add more struct fields at the bottom"]
    pub age: ::std::os::raw::c_int,
    #[doc = " :member:`version_num` is the :macro:`NGTCP2_VERSION_NUM` number\n (since :member:`age` ==1)"]
    pub version_num: ::std::os::raw::c_int,
    #[doc = " :member:`version_str` points to the :macro:`NGTCP2_VERSION`\n string (since :member:`age` ==1)"]
    pub version_str: *const ::std::os::raw::c_char,
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_version` returns a pointer to a :type:`ngtcp2_info` struct\n with version information about the run-time library in use.  The\n |least_version| argument can be set to a 24 bit numerical value for\n the least accepted version number, and if the condition is not met,\n this function will return a ``NULL``.  Pass in 0 to skip the\n version checking."]
    pub fn ngtcp2_version(least_version: ::std::os::raw::c_int) -> *const ngtcp2_info;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_is_bidi_stream` returns nonzero if |stream_id| denotes\n bidirectional stream."]
    pub fn ngtcp2_is_bidi_stream(stream_id: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_path_copy` copies |src| into |dest|.  This function assumes\n that |dest| has enough buffer to store the deep copy of\n :member:`src->local <ngtcp2_path.local>` and :member:`src->remote\n <ngtcp2_path.remote>`."]
    pub fn ngtcp2_path_copy(dest: *mut ngtcp2_path, src: *const ngtcp2_path);
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_path_eq` returns nonzero if |a| and |b| shares the same\n local and remote addresses."]
    pub fn ngtcp2_path_eq(a: *const ngtcp2_path, b: *const ngtcp2_path) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_is_supported_version` returns nonzero if the library\n supports QUIC version |version|."]
    pub fn ngtcp2_is_supported_version(version: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_is_reserved_version` returns nonzero if |version| is a\n reserved version."]
    pub fn ngtcp2_is_reserved_version(version: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `ngtcp2_select_version` selects and returns a version from the\n version set |offered_versions| of |offered_versionslen| elements.\n |preferred_versions| of |preferred_versionslen| elements specifies\n the preference of versions, which is sorted in the order of\n preference.  All versions included in |preferred_versions| must be\n supported by the library, that is, passing any version in the array\n to `ngtcp2_is_supported_version` must return nonzero.  This\n function is intended to be used by client when it receives Version\n Negotiation packet.  If no version is selected, this function\n returns 0."]
    pub fn ngtcp2_select_version(
        preferred_versions: *const u32,
        preferred_versionslen: usize,
        offered_versions: *const u32,
        offered_versionslen: usize,
    ) -> u32;
}
